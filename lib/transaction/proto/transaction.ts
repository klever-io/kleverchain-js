/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.4
 * source: lib/transaction/proto/transaction.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../../google/protobuf/any";
import * as pb_1 from "google-protobuf";
export class TXContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Type?: TXContractContractType;
        Parameter?: dependency_1.Any;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Type" in data && data.Type != undefined) {
                this.Type = data.Type;
            }
            if ("Parameter" in data && data.Parameter != undefined) {
                this.Parameter = data.Parameter;
            }
        }
    }
    get Type() {
        return pb_1.Message.getFieldWithDefault(this, 1, TXContractContractType.TransferContractType) as TXContractContractType;
    }
    set Type(value: TXContractContractType) {
        pb_1.Message.setField(this, 1, value);
    }
    get Parameter() {
        return pb_1.Message.getWrapperField(this, dependency_1.Any, 2) as dependency_1.Any;
    }
    set Parameter(value: dependency_1.Any) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_Parameter() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        Type?: TXContractContractType;
        Parameter?: ReturnType<typeof dependency_1.Any.prototype.toObject>;
    }): TXContract {
        const message = new TXContract({});
        if (data.Type != null) {
            message.Type = data.Type;
        }
        if (data.Parameter != null) {
            message.Parameter = dependency_1.Any.fromObject(data.Parameter);
        }
        return message;
    }
    toObject() {
        const data: {
            Type?: TXContractContractType;
            Parameter?: ReturnType<typeof dependency_1.Any.prototype.toObject>;
        } = {};
        if (this.Type != null) {
            data.Type = this.Type;
        }
        if (this.Parameter != null) {
            data.Parameter = this.Parameter.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Type != TXContractContractType.TransferContractType)
            writer.writeEnum(1, this.Type);
        if (this.has_Parameter)
            writer.writeMessage(2, this.Parameter, () => this.Parameter.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TXContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TXContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.Type = reader.readEnum();
                    break;
                case 2:
                    reader.readMessage(message.Parameter, () => message.Parameter = dependency_1.Any.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TXContract {
        return TXContract.deserialize(bytes);
    }
}
export enum TXContractContractType {
    TransferContractType = 0,
    CreateAssetContractType = 1,
    CreateValidatorContractType = 2,
    ValidatorConfigContractType = 3,
    FreezeContractType = 4,
    UnfreezeContractType = 5,
    DelegateContractType = 6,
    UndelegateContractType = 7,
    WithdrawContractType = 8,
    ClaimContractType = 9,
    UnjailContractType = 10,
    AssetTriggerContractType = 11,
    SetAccountNameContractType = 12,
    ProposalContractType = 13,
    VoteContractType = 14,
    ConfigITOContractType = 15,
    SetITOPricesContractType = 16,
    BuyContractType = 17,
    SellContractType = 18,
    CancelMarketOrderContractType = 19,
    CreateMarketplaceContractType = 20,
    ConfigMarketplaceContractType = 21,
    UpdateAccountPermissionContractType = 22
}
export class Transaction extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        RawData?: TransactionRaw;
        Signature?: Uint8Array[];
        Result?: TransactionTXResult;
        ResultCode?: TransactionTXResultCode;
        Receipts?: TransactionReceipt[];
        Block?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 5], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("RawData" in data && data.RawData != undefined) {
                this.RawData = data.RawData;
            }
            if ("Signature" in data && data.Signature != undefined) {
                this.Signature = data.Signature;
            }
            if ("Result" in data && data.Result != undefined) {
                this.Result = data.Result;
            }
            if ("ResultCode" in data && data.ResultCode != undefined) {
                this.ResultCode = data.ResultCode;
            }
            if ("Receipts" in data && data.Receipts != undefined) {
                this.Receipts = data.Receipts;
            }
            if ("Block" in data && data.Block != undefined) {
                this.Block = data.Block;
            }
        }
    }
    get RawData() {
        return pb_1.Message.getWrapperField(this, TransactionRaw, 1) as TransactionRaw;
    }
    set RawData(value: TransactionRaw) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_RawData() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get Signature() {
        return pb_1.Message.getFieldWithDefault(this, 2, []) as Uint8Array[];
    }
    set Signature(value: Uint8Array[]) {
        pb_1.Message.setField(this, 2, value);
    }
    get Result() {
        return pb_1.Message.getFieldWithDefault(this, 3, TransactionTXResult.SUCCESS) as TransactionTXResult;
    }
    set Result(value: TransactionTXResult) {
        pb_1.Message.setField(this, 3, value);
    }
    get ResultCode() {
        return pb_1.Message.getFieldWithDefault(this, 4, TransactionTXResultCode.Ok) as TransactionTXResultCode;
    }
    set ResultCode(value: TransactionTXResultCode) {
        pb_1.Message.setField(this, 4, value);
    }
    get Receipts() {
        return pb_1.Message.getRepeatedWrapperField(this, TransactionReceipt, 5) as TransactionReceipt[];
    }
    set Receipts(value: TransactionReceipt[]) {
        pb_1.Message.setRepeatedWrapperField(this, 5, value);
    }
    get Block() {
        return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
    }
    set Block(value: number) {
        pb_1.Message.setField(this, 6, value);
    }
    static fromObject(data: {
        RawData?: ReturnType<typeof TransactionRaw.prototype.toObject>;
        Signature?: Uint8Array[];
        Result?: TransactionTXResult;
        ResultCode?: TransactionTXResultCode;
        Receipts?: ReturnType<typeof TransactionReceipt.prototype.toObject>[];
        Block?: number;
    }): Transaction {
        const message = new Transaction({});
        if (data.RawData != null) {
            message.RawData = TransactionRaw.fromObject(data.RawData);
        }
        if (data.Signature != null) {
            message.Signature = data.Signature;
        }
        if (data.Result != null) {
            message.Result = data.Result;
        }
        if (data.ResultCode != null) {
            message.ResultCode = data.ResultCode;
        }
        if (data.Receipts != null) {
            message.Receipts = data.Receipts.map(item => TransactionReceipt.fromObject(item));
        }
        if (data.Block != null) {
            message.Block = data.Block;
        }
        return message;
    }
    toObject() {
        const data: {
            RawData?: ReturnType<typeof TransactionRaw.prototype.toObject>;
            Signature?: Uint8Array[];
            Result?: TransactionTXResult;
            ResultCode?: TransactionTXResultCode;
            Receipts?: ReturnType<typeof TransactionReceipt.prototype.toObject>[];
            Block?: number;
        } = {};
        if (this.RawData != null) {
            data.RawData = this.RawData.toObject();
        }
        if (this.Signature != null) {
            data.Signature = this.Signature;
        }
        if (this.Result != null) {
            data.Result = this.Result;
        }
        if (this.ResultCode != null) {
            data.ResultCode = this.ResultCode;
        }
        if (this.Receipts != null) {
            data.Receipts = this.Receipts.map((item: TransactionReceipt) => item.toObject());
        }
        if (this.Block != null) {
            data.Block = this.Block;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_RawData)
            writer.writeMessage(1, this.RawData, () => this.RawData.serialize(writer));
        if (this.Signature.length)
            writer.writeRepeatedBytes(2, this.Signature);
        if (this.Result != TransactionTXResult.SUCCESS)
            writer.writeEnum(3, this.Result);
        if (this.ResultCode != TransactionTXResultCode.Ok)
            writer.writeEnum(4, this.ResultCode);
        if (this.Receipts.length)
            writer.writeRepeatedMessage(5, this.Receipts, (item: TransactionReceipt) => item.serialize(writer));
        if (this.Block != 0)
            writer.writeUint64(6, this.Block);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Transaction {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Transaction();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.RawData, () => message.RawData = TransactionRaw.deserialize(reader));
                    break;
                case 2:
                    pb_1.Message.addToRepeatedField(message, 2, reader.readBytes());
                    break;
                case 3:
                    message.Result = reader.readEnum();
                    break;
                case 4:
                    message.ResultCode = reader.readEnum();
                    break;
                case 5:
                    reader.readMessage(message.Receipts, () => pb_1.Message.addToRepeatedWrapperField(message, 5, TransactionReceipt.deserialize(reader), TransactionReceipt));
                    break;
                case 6:
                    message.Block = reader.readUint64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Transaction {
        return Transaction.deserialize(bytes);
    }
}
export enum TransactionTXResult {
    SUCCESS = 0,
    FAILED = 1
}
export enum TransactionTXResultCode {
    Ok = 0,
    OutOfFunds = 1,
    AccountError = 2,
    AssetError = 3,
    ContractInvalid = 4,
    ContractNotFound = 5,
    FeeInvalid = 6,
    ParameterInvalid = 7,
    APRInvalid = 8,
    AssetIDInvalid = 9,
    AssetTypeInvalid = 10,
    AssetCantBeMinted = 11,
    AssetCantBeBurned = 12,
    AssetCantBePaused = 13,
    AssetCantBeDelegated = 14,
    AssetOwnerCantBeChanged = 15,
    AccountNotOwner = 16,
    CommissionTooHigh = 17,
    DelegationAmountInvalid = 18,
    ProposalNotActive = 19,
    ValueInvalid = 20,
    AmountInvalid = 21,
    BucketIDInvalid = 22,
    KeyConflict = 23,
    MaxDelegationAmount = 24,
    InvalidPeerKey = 25,
    MinKFIStakedUnreached = 26,
    MaxSupplyExeeced = 27,
    SaveAccountError = 28,
    LoadAccountError = 29,
    SameAccountError = 30,
    AssetPaused = 31,
    DeletegateError = 32,
    WithdrawNotAvailable = 33,
    ErrOverflow = 34,
    SetStakingErr = 35,
    SetMarketOrderErr = 36,
    BalanceError = 37,
    KAPPError = 38,
    UnfreezeError = 39,
    UndeletegateError = 40,
    WithdrawError = 41,
    ClaimError = 42,
    BucketsExceded = 43,
    AssetCantBeWiped = 44,
    AssetCantAddRoles = 45,
    FreezeError = 46,
    Fail = 99
}
export class TransactionRaw extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Nonce?: number;
        Sender?: Uint8Array;
        Contract?: TXContract[];
        PermissionID?: number;
        Data?: Uint8Array[];
        KAppFee?: number;
        BandwidthFee?: number;
        Version?: number;
        ChainID?: Uint8Array;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6, 10], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Nonce" in data && data.Nonce != undefined) {
                this.Nonce = data.Nonce;
            }
            if ("Sender" in data && data.Sender != undefined) {
                this.Sender = data.Sender;
            }
            if ("Contract" in data && data.Contract != undefined) {
                this.Contract = data.Contract;
            }
            if ("PermissionID" in data && data.PermissionID != undefined) {
                this.PermissionID = data.PermissionID;
            }
            if ("Data" in data && data.Data != undefined) {
                this.Data = data.Data;
            }
            if ("KAppFee" in data && data.KAppFee != undefined) {
                this.KAppFee = data.KAppFee;
            }
            if ("BandwidthFee" in data && data.BandwidthFee != undefined) {
                this.BandwidthFee = data.BandwidthFee;
            }
            if ("Version" in data && data.Version != undefined) {
                this.Version = data.Version;
            }
            if ("ChainID" in data && data.ChainID != undefined) {
                this.ChainID = data.ChainID;
            }
        }
    }
    get Nonce() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set Nonce(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get Sender() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set Sender(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get Contract() {
        return pb_1.Message.getRepeatedWrapperField(this, TXContract, 6) as TXContract[];
    }
    set Contract(value: TXContract[]) {
        pb_1.Message.setRepeatedWrapperField(this, 6, value);
    }
    get PermissionID() {
        return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
    }
    set PermissionID(value: number) {
        pb_1.Message.setField(this, 7, value);
    }
    get Data() {
        return pb_1.Message.getFieldWithDefault(this, 10, []) as Uint8Array[];
    }
    set Data(value: Uint8Array[]) {
        pb_1.Message.setField(this, 10, value);
    }
    get KAppFee() {
        return pb_1.Message.getFieldWithDefault(this, 13, 0) as number;
    }
    set KAppFee(value: number) {
        pb_1.Message.setField(this, 13, value);
    }
    get BandwidthFee() {
        return pb_1.Message.getFieldWithDefault(this, 14, 0) as number;
    }
    set BandwidthFee(value: number) {
        pb_1.Message.setField(this, 14, value);
    }
    get Version() {
        return pb_1.Message.getFieldWithDefault(this, 15, 0) as number;
    }
    set Version(value: number) {
        pb_1.Message.setField(this, 15, value);
    }
    get ChainID() {
        return pb_1.Message.getFieldWithDefault(this, 16, new Uint8Array()) as Uint8Array;
    }
    set ChainID(value: Uint8Array) {
        pb_1.Message.setField(this, 16, value);
    }
    static fromObject(data: {
        Nonce?: number;
        Sender?: Uint8Array;
        Contract?: ReturnType<typeof TXContract.prototype.toObject>[];
        PermissionID?: number;
        Data?: Uint8Array[];
        KAppFee?: number;
        BandwidthFee?: number;
        Version?: number;
        ChainID?: Uint8Array;
    }): TransactionRaw {
        const message = new TransactionRaw({});
        if (data.Nonce != null) {
            message.Nonce = data.Nonce;
        }
        if (data.Sender != null) {
            message.Sender = data.Sender;
        }
        if (data.Contract != null) {
            message.Contract = data.Contract.map(item => TXContract.fromObject(item));
        }
        if (data.PermissionID != null) {
            message.PermissionID = data.PermissionID;
        }
        if (data.Data != null) {
            message.Data = data.Data;
        }
        if (data.KAppFee != null) {
            message.KAppFee = data.KAppFee;
        }
        if (data.BandwidthFee != null) {
            message.BandwidthFee = data.BandwidthFee;
        }
        if (data.Version != null) {
            message.Version = data.Version;
        }
        if (data.ChainID != null) {
            message.ChainID = data.ChainID;
        }
        return message;
    }
    toObject() {
        const data: {
            Nonce?: number;
            Sender?: Uint8Array;
            Contract?: ReturnType<typeof TXContract.prototype.toObject>[];
            PermissionID?: number;
            Data?: Uint8Array[];
            KAppFee?: number;
            BandwidthFee?: number;
            Version?: number;
            ChainID?: Uint8Array;
        } = {};
        if (this.Nonce != null) {
            data.Nonce = this.Nonce;
        }
        if (this.Sender != null) {
            data.Sender = this.Sender;
        }
        if (this.Contract != null) {
            data.Contract = this.Contract.map((item: TXContract) => item.toObject());
        }
        if (this.PermissionID != null) {
            data.PermissionID = this.PermissionID;
        }
        if (this.Data != null) {
            data.Data = this.Data;
        }
        if (this.KAppFee != null) {
            data.KAppFee = this.KAppFee;
        }
        if (this.BandwidthFee != null) {
            data.BandwidthFee = this.BandwidthFee;
        }
        if (this.Version != null) {
            data.Version = this.Version;
        }
        if (this.ChainID != null) {
            data.ChainID = this.ChainID;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Nonce != 0)
            writer.writeUint64(1, this.Nonce);
        if (this.Sender.length)
            writer.writeBytes(2, this.Sender);
        if (this.Contract.length)
            writer.writeRepeatedMessage(6, this.Contract, (item: TXContract) => item.serialize(writer));
        if (this.PermissionID != 0)
            writer.writeInt32(7, this.PermissionID);
        if (this.Data.length)
            writer.writeRepeatedBytes(10, this.Data);
        if (this.KAppFee != 0)
            writer.writeInt64(13, this.KAppFee);
        if (this.BandwidthFee != 0)
            writer.writeInt64(14, this.BandwidthFee);
        if (this.Version != 0)
            writer.writeUint32(15, this.Version);
        if (this.ChainID.length)
            writer.writeBytes(16, this.ChainID);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TransactionRaw {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransactionRaw();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.Nonce = reader.readUint64();
                    break;
                case 2:
                    message.Sender = reader.readBytes();
                    break;
                case 6:
                    reader.readMessage(message.Contract, () => pb_1.Message.addToRepeatedWrapperField(message, 6, TXContract.deserialize(reader), TXContract));
                    break;
                case 7:
                    message.PermissionID = reader.readInt32();
                    break;
                case 10:
                    pb_1.Message.addToRepeatedField(message, 10, reader.readBytes());
                    break;
                case 13:
                    message.KAppFee = reader.readInt64();
                    break;
                case 14:
                    message.BandwidthFee = reader.readInt64();
                    break;
                case 15:
                    message.Version = reader.readUint32();
                    break;
                case 16:
                    message.ChainID = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TransactionRaw {
        return TransactionRaw.deserialize(bytes);
    }
}
export class TransactionReceipt extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Data?: Uint8Array[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Data" in data && data.Data != undefined) {
                this.Data = data.Data;
            }
        }
    }
    get Data() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as Uint8Array[];
    }
    set Data(value: Uint8Array[]) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        Data?: Uint8Array[];
    }): TransactionReceipt {
        const message = new TransactionReceipt({});
        if (data.Data != null) {
            message.Data = data.Data;
        }
        return message;
    }
    toObject() {
        const data: {
            Data?: Uint8Array[];
        } = {};
        if (this.Data != null) {
            data.Data = this.Data;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Data.length)
            writer.writeRepeatedBytes(1, this.Data);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TransactionReceipt {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransactionReceipt();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    pb_1.Message.addToRepeatedField(message, 1, reader.readBytes());
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TransactionReceipt {
        return TransactionReceipt.deserialize(bytes);
    }
}
