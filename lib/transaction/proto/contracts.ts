/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.4
 * source: lib/transaction/proto/contracts.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export class TransferContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        ToAddress?: Uint8Array;
        AssetID?: Uint8Array;
        Amount?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ToAddress" in data && data.ToAddress != undefined) {
                this.ToAddress = data.ToAddress;
            }
            if ("AssetID" in data && data.AssetID != undefined) {
                this.AssetID = data.AssetID;
            }
            if ("Amount" in data && data.Amount != undefined) {
                this.Amount = data.Amount;
            }
        }
    }
    get ToAddress() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set ToAddress(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get AssetID() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set AssetID(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get Amount() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set Amount(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        ToAddress?: Uint8Array;
        AssetID?: Uint8Array;
        Amount?: number;
    }): TransferContract {
        const message = new TransferContract({});
        if (data.ToAddress != null) {
            message.ToAddress = data.ToAddress;
        }
        if (data.AssetID != null) {
            message.AssetID = data.AssetID;
        }
        if (data.Amount != null) {
            message.Amount = data.Amount;
        }
        return message;
    }
    toObject() {
        const data: {
            ToAddress?: Uint8Array;
            AssetID?: Uint8Array;
            Amount?: number;
        } = {};
        if (this.ToAddress != null) {
            data.ToAddress = this.ToAddress;
        }
        if (this.AssetID != null) {
            data.AssetID = this.AssetID;
        }
        if (this.Amount != null) {
            data.Amount = this.Amount;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.ToAddress.length)
            writer.writeBytes(1, this.ToAddress);
        if (this.AssetID.length)
            writer.writeBytes(2, this.AssetID);
        if (this.Amount != 0)
            writer.writeInt64(3, this.Amount);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TransferContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransferContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.ToAddress = reader.readBytes();
                    break;
                case 2:
                    message.AssetID = reader.readBytes();
                    break;
                case 3:
                    message.Amount = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TransferContract {
        return TransferContract.deserialize(bytes);
    }
}
export class CreateAssetContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Type?: CreateAssetContractEnumAssetType;
        Name?: Uint8Array;
        Ticker?: Uint8Array;
        OwnerAddress?: Uint8Array;
        Logo?: string;
        URIs?: Map<string, string>;
        Precision?: number;
        InitialSupply?: number;
        MaxSupply?: number;
        Royalties?: RoyaltiesInfo;
        Properties?: PropertiesInfo;
        Attributes?: AttributesInfo;
        Staking?: StakingInfo;
        Roles?: RolesInfo[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [14], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Type" in data && data.Type != undefined) {
                this.Type = data.Type;
            }
            if ("Name" in data && data.Name != undefined) {
                this.Name = data.Name;
            }
            if ("Ticker" in data && data.Ticker != undefined) {
                this.Ticker = data.Ticker;
            }
            if ("OwnerAddress" in data && data.OwnerAddress != undefined) {
                this.OwnerAddress = data.OwnerAddress;
            }
            if ("Logo" in data && data.Logo != undefined) {
                this.Logo = data.Logo;
            }
            if ("URIs" in data && data.URIs != undefined) {
                this.URIs = data.URIs;
            }
            if ("Precision" in data && data.Precision != undefined) {
                this.Precision = data.Precision;
            }
            if ("InitialSupply" in data && data.InitialSupply != undefined) {
                this.InitialSupply = data.InitialSupply;
            }
            if ("MaxSupply" in data && data.MaxSupply != undefined) {
                this.MaxSupply = data.MaxSupply;
            }
            if ("Royalties" in data && data.Royalties != undefined) {
                this.Royalties = data.Royalties;
            }
            if ("Properties" in data && data.Properties != undefined) {
                this.Properties = data.Properties;
            }
            if ("Attributes" in data && data.Attributes != undefined) {
                this.Attributes = data.Attributes;
            }
            if ("Staking" in data && data.Staking != undefined) {
                this.Staking = data.Staking;
            }
            if ("Roles" in data && data.Roles != undefined) {
                this.Roles = data.Roles;
            }
        }
        if (!this.URIs)
            this.URIs = new Map();
    }
    get Type() {
        return pb_1.Message.getFieldWithDefault(this, 1, CreateAssetContractEnumAssetType.Fungible) as CreateAssetContractEnumAssetType;
    }
    set Type(value: CreateAssetContractEnumAssetType) {
        pb_1.Message.setField(this, 1, value);
    }
    get Name() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set Name(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get Ticker() {
        return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array()) as Uint8Array;
    }
    set Ticker(value: Uint8Array) {
        pb_1.Message.setField(this, 3, value);
    }
    get OwnerAddress() {
        return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array()) as Uint8Array;
    }
    set OwnerAddress(value: Uint8Array) {
        pb_1.Message.setField(this, 4, value);
    }
    get Logo() {
        return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
    }
    set Logo(value: string) {
        pb_1.Message.setField(this, 5, value);
    }
    get URIs() {
        return pb_1.Message.getField(this, 6) as any as Map<string, string>;
    }
    set URIs(value: Map<string, string>) {
        pb_1.Message.setField(this, 6, value as any);
    }
    get Precision() {
        return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
    }
    set Precision(value: number) {
        pb_1.Message.setField(this, 7, value);
    }
    get InitialSupply() {
        return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
    }
    set InitialSupply(value: number) {
        pb_1.Message.setField(this, 8, value);
    }
    get MaxSupply() {
        return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
    }
    set MaxSupply(value: number) {
        pb_1.Message.setField(this, 9, value);
    }
    get Royalties() {
        return pb_1.Message.getWrapperField(this, RoyaltiesInfo, 10) as RoyaltiesInfo;
    }
    set Royalties(value: RoyaltiesInfo) {
        pb_1.Message.setWrapperField(this, 10, value);
    }
    get has_Royalties() {
        return pb_1.Message.getField(this, 10) != null;
    }
    get Properties() {
        return pb_1.Message.getWrapperField(this, PropertiesInfo, 11) as PropertiesInfo;
    }
    set Properties(value: PropertiesInfo) {
        pb_1.Message.setWrapperField(this, 11, value);
    }
    get has_Properties() {
        return pb_1.Message.getField(this, 11) != null;
    }
    get Attributes() {
        return pb_1.Message.getWrapperField(this, AttributesInfo, 12) as AttributesInfo;
    }
    set Attributes(value: AttributesInfo) {
        pb_1.Message.setWrapperField(this, 12, value);
    }
    get has_Attributes() {
        return pb_1.Message.getField(this, 12) != null;
    }
    get Staking() {
        return pb_1.Message.getWrapperField(this, StakingInfo, 13) as StakingInfo;
    }
    set Staking(value: StakingInfo) {
        pb_1.Message.setWrapperField(this, 13, value);
    }
    get has_Staking() {
        return pb_1.Message.getField(this, 13) != null;
    }
    get Roles() {
        return pb_1.Message.getRepeatedWrapperField(this, RolesInfo, 14) as RolesInfo[];
    }
    set Roles(value: RolesInfo[]) {
        pb_1.Message.setRepeatedWrapperField(this, 14, value);
    }
    static fromObject(data: {
        Type?: CreateAssetContractEnumAssetType;
        Name?: Uint8Array;
        Ticker?: Uint8Array;
        OwnerAddress?: Uint8Array;
        Logo?: string;
        URIs?: {
            [key: string]: string;
        };
        Precision?: number;
        InitialSupply?: number;
        MaxSupply?: number;
        Royalties?: ReturnType<typeof RoyaltiesInfo.prototype.toObject>;
        Properties?: ReturnType<typeof PropertiesInfo.prototype.toObject>;
        Attributes?: ReturnType<typeof AttributesInfo.prototype.toObject>;
        Staking?: ReturnType<typeof StakingInfo.prototype.toObject>;
        Roles?: ReturnType<typeof RolesInfo.prototype.toObject>[];
    }): CreateAssetContract {
        const message = new CreateAssetContract({});
        if (data.Type != null) {
            message.Type = data.Type;
        }
        if (data.Name != null) {
            message.Name = data.Name;
        }
        if (data.Ticker != null) {
            message.Ticker = data.Ticker;
        }
        if (data.OwnerAddress != null) {
            message.OwnerAddress = data.OwnerAddress;
        }
        if (data.Logo != null) {
            message.Logo = data.Logo;
        }
        if (typeof data.URIs == "object") {
            message.URIs = new Map(Object.entries(data.URIs));
        }
        if (data.Precision != null) {
            message.Precision = data.Precision;
        }
        if (data.InitialSupply != null) {
            message.InitialSupply = data.InitialSupply;
        }
        if (data.MaxSupply != null) {
            message.MaxSupply = data.MaxSupply;
        }
        if (data.Royalties != null) {
            message.Royalties = RoyaltiesInfo.fromObject(data.Royalties);
        }
        if (data.Properties != null) {
            message.Properties = PropertiesInfo.fromObject(data.Properties);
        }
        if (data.Attributes != null) {
            message.Attributes = AttributesInfo.fromObject(data.Attributes);
        }
        if (data.Staking != null) {
            message.Staking = StakingInfo.fromObject(data.Staking);
        }
        if (data.Roles != null) {
            message.Roles = data.Roles.map(item => RolesInfo.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            Type?: CreateAssetContractEnumAssetType;
            Name?: Uint8Array;
            Ticker?: Uint8Array;
            OwnerAddress?: Uint8Array;
            Logo?: string;
            URIs?: {
                [key: string]: string;
            };
            Precision?: number;
            InitialSupply?: number;
            MaxSupply?: number;
            Royalties?: ReturnType<typeof RoyaltiesInfo.prototype.toObject>;
            Properties?: ReturnType<typeof PropertiesInfo.prototype.toObject>;
            Attributes?: ReturnType<typeof AttributesInfo.prototype.toObject>;
            Staking?: ReturnType<typeof StakingInfo.prototype.toObject>;
            Roles?: ReturnType<typeof RolesInfo.prototype.toObject>[];
        } = {};
        if (this.Type != null) {
            data.Type = this.Type;
        }
        if (this.Name != null) {
            data.Name = this.Name;
        }
        if (this.Ticker != null) {
            data.Ticker = this.Ticker;
        }
        if (this.OwnerAddress != null) {
            data.OwnerAddress = this.OwnerAddress;
        }
        if (this.Logo != null) {
            data.Logo = this.Logo;
        }
        if (this.URIs.size > 0) {
            data.URIs = Object.fromEntries(this.URIs);
        }
        if (this.Precision != null) {
            data.Precision = this.Precision;
        }
        if (this.InitialSupply != null) {
            data.InitialSupply = this.InitialSupply;
        }
        if (this.MaxSupply != null) {
            data.MaxSupply = this.MaxSupply;
        }
        if (this.Royalties != null) {
            data.Royalties = this.Royalties.toObject();
        }
        if (this.Properties != null) {
            data.Properties = this.Properties.toObject();
        }
        if (this.Attributes != null) {
            data.Attributes = this.Attributes.toObject();
        }
        if (this.Staking != null) {
            data.Staking = this.Staking.toObject();
        }
        if (this.Roles != null) {
            data.Roles = this.Roles.map((item: RolesInfo) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Type != CreateAssetContractEnumAssetType.Fungible)
            writer.writeEnum(1, this.Type);
        if (this.Name.length)
            writer.writeBytes(2, this.Name);
        if (this.Ticker.length)
            writer.writeBytes(3, this.Ticker);
        if (this.OwnerAddress.length)
            writer.writeBytes(4, this.OwnerAddress);
        if (this.Logo.length)
            writer.writeString(5, this.Logo);
        for (const [key, value] of this.URIs) {
            writer.writeMessage(6, this.URIs, () => {
                writer.writeString(1, key);
                writer.writeString(2, value);
            });
        }
        if (this.Precision != 0)
            writer.writeUint32(7, this.Precision);
        if (this.InitialSupply != 0)
            writer.writeInt64(8, this.InitialSupply);
        if (this.MaxSupply != 0)
            writer.writeInt64(9, this.MaxSupply);
        if (this.has_Royalties)
            writer.writeMessage(10, this.Royalties, () => this.Royalties.serialize(writer));
        if (this.has_Properties)
            writer.writeMessage(11, this.Properties, () => this.Properties.serialize(writer));
        if (this.has_Attributes)
            writer.writeMessage(12, this.Attributes, () => this.Attributes.serialize(writer));
        if (this.has_Staking)
            writer.writeMessage(13, this.Staking, () => this.Staking.serialize(writer));
        if (this.Roles.length)
            writer.writeRepeatedMessage(14, this.Roles, (item: RolesInfo) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateAssetContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateAssetContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.Type = reader.readEnum();
                    break;
                case 2:
                    message.Name = reader.readBytes();
                    break;
                case 3:
                    message.Ticker = reader.readBytes();
                    break;
                case 4:
                    message.OwnerAddress = reader.readBytes();
                    break;
                case 5:
                    message.Logo = reader.readString();
                    break;
                case 6:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.URIs as any, reader, reader.readString, reader.readString));
                    break;
                case 7:
                    message.Precision = reader.readUint32();
                    break;
                case 8:
                    message.InitialSupply = reader.readInt64();
                    break;
                case 9:
                    message.MaxSupply = reader.readInt64();
                    break;
                case 10:
                    reader.readMessage(message.Royalties, () => message.Royalties = RoyaltiesInfo.deserialize(reader));
                    break;
                case 11:
                    reader.readMessage(message.Properties, () => message.Properties = PropertiesInfo.deserialize(reader));
                    break;
                case 12:
                    reader.readMessage(message.Attributes, () => message.Attributes = AttributesInfo.deserialize(reader));
                    break;
                case 13:
                    reader.readMessage(message.Staking, () => message.Staking = StakingInfo.deserialize(reader));
                    break;
                case 14:
                    reader.readMessage(message.Roles, () => pb_1.Message.addToRepeatedWrapperField(message, 14, RolesInfo.deserialize(reader), RolesInfo));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CreateAssetContract {
        return CreateAssetContract.deserialize(bytes);
    }
}
export enum CreateAssetContractEnumAssetType {
    Fungible = 0,
    NonFungible = 1
}
export class PropertiesInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        CanFreeze?: boolean;
        CanWipe?: boolean;
        CanPause?: boolean;
        CanMint?: boolean;
        CanBurn?: boolean;
        CanChangeOwner?: boolean;
        CanAddRoles?: boolean;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("CanFreeze" in data && data.CanFreeze != undefined) {
                this.CanFreeze = data.CanFreeze;
            }
            if ("CanWipe" in data && data.CanWipe != undefined) {
                this.CanWipe = data.CanWipe;
            }
            if ("CanPause" in data && data.CanPause != undefined) {
                this.CanPause = data.CanPause;
            }
            if ("CanMint" in data && data.CanMint != undefined) {
                this.CanMint = data.CanMint;
            }
            if ("CanBurn" in data && data.CanBurn != undefined) {
                this.CanBurn = data.CanBurn;
            }
            if ("CanChangeOwner" in data && data.CanChangeOwner != undefined) {
                this.CanChangeOwner = data.CanChangeOwner;
            }
            if ("CanAddRoles" in data && data.CanAddRoles != undefined) {
                this.CanAddRoles = data.CanAddRoles;
            }
        }
    }
    get CanFreeze() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set CanFreeze(value: boolean) {
        pb_1.Message.setField(this, 1, value);
    }
    get CanWipe() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set CanWipe(value: boolean) {
        pb_1.Message.setField(this, 2, value);
    }
    get CanPause() {
        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
    }
    set CanPause(value: boolean) {
        pb_1.Message.setField(this, 3, value);
    }
    get CanMint() {
        return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
    }
    set CanMint(value: boolean) {
        pb_1.Message.setField(this, 4, value);
    }
    get CanBurn() {
        return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
    }
    set CanBurn(value: boolean) {
        pb_1.Message.setField(this, 5, value);
    }
    get CanChangeOwner() {
        return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
    }
    set CanChangeOwner(value: boolean) {
        pb_1.Message.setField(this, 6, value);
    }
    get CanAddRoles() {
        return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
    }
    set CanAddRoles(value: boolean) {
        pb_1.Message.setField(this, 7, value);
    }
    static fromObject(data: {
        CanFreeze?: boolean;
        CanWipe?: boolean;
        CanPause?: boolean;
        CanMint?: boolean;
        CanBurn?: boolean;
        CanChangeOwner?: boolean;
        CanAddRoles?: boolean;
    }): PropertiesInfo {
        const message = new PropertiesInfo({});
        if (data.CanFreeze != null) {
            message.CanFreeze = data.CanFreeze;
        }
        if (data.CanWipe != null) {
            message.CanWipe = data.CanWipe;
        }
        if (data.CanPause != null) {
            message.CanPause = data.CanPause;
        }
        if (data.CanMint != null) {
            message.CanMint = data.CanMint;
        }
        if (data.CanBurn != null) {
            message.CanBurn = data.CanBurn;
        }
        if (data.CanChangeOwner != null) {
            message.CanChangeOwner = data.CanChangeOwner;
        }
        if (data.CanAddRoles != null) {
            message.CanAddRoles = data.CanAddRoles;
        }
        return message;
    }
    toObject() {
        const data: {
            CanFreeze?: boolean;
            CanWipe?: boolean;
            CanPause?: boolean;
            CanMint?: boolean;
            CanBurn?: boolean;
            CanChangeOwner?: boolean;
            CanAddRoles?: boolean;
        } = {};
        if (this.CanFreeze != null) {
            data.CanFreeze = this.CanFreeze;
        }
        if (this.CanWipe != null) {
            data.CanWipe = this.CanWipe;
        }
        if (this.CanPause != null) {
            data.CanPause = this.CanPause;
        }
        if (this.CanMint != null) {
            data.CanMint = this.CanMint;
        }
        if (this.CanBurn != null) {
            data.CanBurn = this.CanBurn;
        }
        if (this.CanChangeOwner != null) {
            data.CanChangeOwner = this.CanChangeOwner;
        }
        if (this.CanAddRoles != null) {
            data.CanAddRoles = this.CanAddRoles;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.CanFreeze != false)
            writer.writeBool(1, this.CanFreeze);
        if (this.CanWipe != false)
            writer.writeBool(2, this.CanWipe);
        if (this.CanPause != false)
            writer.writeBool(3, this.CanPause);
        if (this.CanMint != false)
            writer.writeBool(4, this.CanMint);
        if (this.CanBurn != false)
            writer.writeBool(5, this.CanBurn);
        if (this.CanChangeOwner != false)
            writer.writeBool(6, this.CanChangeOwner);
        if (this.CanAddRoles != false)
            writer.writeBool(7, this.CanAddRoles);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PropertiesInfo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PropertiesInfo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.CanFreeze = reader.readBool();
                    break;
                case 2:
                    message.CanWipe = reader.readBool();
                    break;
                case 3:
                    message.CanPause = reader.readBool();
                    break;
                case 4:
                    message.CanMint = reader.readBool();
                    break;
                case 5:
                    message.CanBurn = reader.readBool();
                    break;
                case 6:
                    message.CanChangeOwner = reader.readBool();
                    break;
                case 7:
                    message.CanAddRoles = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): PropertiesInfo {
        return PropertiesInfo.deserialize(bytes);
    }
}
export class AttributesInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        IsPaused?: boolean;
        IsNFTMintStopped?: boolean;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("IsPaused" in data && data.IsPaused != undefined) {
                this.IsPaused = data.IsPaused;
            }
            if ("IsNFTMintStopped" in data && data.IsNFTMintStopped != undefined) {
                this.IsNFTMintStopped = data.IsNFTMintStopped;
            }
        }
    }
    get IsPaused() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set IsPaused(value: boolean) {
        pb_1.Message.setField(this, 1, value);
    }
    get IsNFTMintStopped() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set IsNFTMintStopped(value: boolean) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        IsPaused?: boolean;
        IsNFTMintStopped?: boolean;
    }): AttributesInfo {
        const message = new AttributesInfo({});
        if (data.IsPaused != null) {
            message.IsPaused = data.IsPaused;
        }
        if (data.IsNFTMintStopped != null) {
            message.IsNFTMintStopped = data.IsNFTMintStopped;
        }
        return message;
    }
    toObject() {
        const data: {
            IsPaused?: boolean;
            IsNFTMintStopped?: boolean;
        } = {};
        if (this.IsPaused != null) {
            data.IsPaused = this.IsPaused;
        }
        if (this.IsNFTMintStopped != null) {
            data.IsNFTMintStopped = this.IsNFTMintStopped;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.IsPaused != false)
            writer.writeBool(1, this.IsPaused);
        if (this.IsNFTMintStopped != false)
            writer.writeBool(2, this.IsNFTMintStopped);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AttributesInfo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AttributesInfo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.IsPaused = reader.readBool();
                    break;
                case 2:
                    message.IsNFTMintStopped = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): AttributesInfo {
        return AttributesInfo.deserialize(bytes);
    }
}
export class StakingInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Type?: StakingInfoInterestType;
        APR?: number;
        MinEpochsToClaim?: number;
        MinEpochsToUnstake?: number;
        MinEpochsToWithdraw?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Type" in data && data.Type != undefined) {
                this.Type = data.Type;
            }
            if ("APR" in data && data.APR != undefined) {
                this.APR = data.APR;
            }
            if ("MinEpochsToClaim" in data && data.MinEpochsToClaim != undefined) {
                this.MinEpochsToClaim = data.MinEpochsToClaim;
            }
            if ("MinEpochsToUnstake" in data && data.MinEpochsToUnstake != undefined) {
                this.MinEpochsToUnstake = data.MinEpochsToUnstake;
            }
            if ("MinEpochsToWithdraw" in data && data.MinEpochsToWithdraw != undefined) {
                this.MinEpochsToWithdraw = data.MinEpochsToWithdraw;
            }
        }
    }
    get Type() {
        return pb_1.Message.getFieldWithDefault(this, 1, StakingInfoInterestType.APRI) as StakingInfoInterestType;
    }
    set Type(value: StakingInfoInterestType) {
        pb_1.Message.setField(this, 1, value);
    }
    get APR() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set APR(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get MinEpochsToClaim() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set MinEpochsToClaim(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get MinEpochsToUnstake() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set MinEpochsToUnstake(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get MinEpochsToWithdraw() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set MinEpochsToWithdraw(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    static fromObject(data: {
        Type?: StakingInfoInterestType;
        APR?: number;
        MinEpochsToClaim?: number;
        MinEpochsToUnstake?: number;
        MinEpochsToWithdraw?: number;
    }): StakingInfo {
        const message = new StakingInfo({});
        if (data.Type != null) {
            message.Type = data.Type;
        }
        if (data.APR != null) {
            message.APR = data.APR;
        }
        if (data.MinEpochsToClaim != null) {
            message.MinEpochsToClaim = data.MinEpochsToClaim;
        }
        if (data.MinEpochsToUnstake != null) {
            message.MinEpochsToUnstake = data.MinEpochsToUnstake;
        }
        if (data.MinEpochsToWithdraw != null) {
            message.MinEpochsToWithdraw = data.MinEpochsToWithdraw;
        }
        return message;
    }
    toObject() {
        const data: {
            Type?: StakingInfoInterestType;
            APR?: number;
            MinEpochsToClaim?: number;
            MinEpochsToUnstake?: number;
            MinEpochsToWithdraw?: number;
        } = {};
        if (this.Type != null) {
            data.Type = this.Type;
        }
        if (this.APR != null) {
            data.APR = this.APR;
        }
        if (this.MinEpochsToClaim != null) {
            data.MinEpochsToClaim = this.MinEpochsToClaim;
        }
        if (this.MinEpochsToUnstake != null) {
            data.MinEpochsToUnstake = this.MinEpochsToUnstake;
        }
        if (this.MinEpochsToWithdraw != null) {
            data.MinEpochsToWithdraw = this.MinEpochsToWithdraw;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Type != StakingInfoInterestType.APRI)
            writer.writeEnum(1, this.Type);
        if (this.APR != 0)
            writer.writeUint32(2, this.APR);
        if (this.MinEpochsToClaim != 0)
            writer.writeUint32(3, this.MinEpochsToClaim);
        if (this.MinEpochsToUnstake != 0)
            writer.writeUint32(4, this.MinEpochsToUnstake);
        if (this.MinEpochsToWithdraw != 0)
            writer.writeUint32(5, this.MinEpochsToWithdraw);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StakingInfo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StakingInfo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.Type = reader.readEnum();
                    break;
                case 2:
                    message.APR = reader.readUint32();
                    break;
                case 3:
                    message.MinEpochsToClaim = reader.readUint32();
                    break;
                case 4:
                    message.MinEpochsToUnstake = reader.readUint32();
                    break;
                case 5:
                    message.MinEpochsToWithdraw = reader.readUint32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StakingInfo {
        return StakingInfo.deserialize(bytes);
    }
}
export enum StakingInfoInterestType {
    APRI = 0,
    FPRI = 1
}
export class RolesInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Address?: Uint8Array;
        HasRoleMint?: boolean;
        HasRoleSetITOPrices?: boolean;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Address" in data && data.Address != undefined) {
                this.Address = data.Address;
            }
            if ("HasRoleMint" in data && data.HasRoleMint != undefined) {
                this.HasRoleMint = data.HasRoleMint;
            }
            if ("HasRoleSetITOPrices" in data && data.HasRoleSetITOPrices != undefined) {
                this.HasRoleSetITOPrices = data.HasRoleSetITOPrices;
            }
        }
    }
    get Address() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set Address(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get HasRoleMint() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set HasRoleMint(value: boolean) {
        pb_1.Message.setField(this, 2, value);
    }
    get HasRoleSetITOPrices() {
        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
    }
    set HasRoleSetITOPrices(value: boolean) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        Address?: Uint8Array;
        HasRoleMint?: boolean;
        HasRoleSetITOPrices?: boolean;
    }): RolesInfo {
        const message = new RolesInfo({});
        if (data.Address != null) {
            message.Address = data.Address;
        }
        if (data.HasRoleMint != null) {
            message.HasRoleMint = data.HasRoleMint;
        }
        if (data.HasRoleSetITOPrices != null) {
            message.HasRoleSetITOPrices = data.HasRoleSetITOPrices;
        }
        return message;
    }
    toObject() {
        const data: {
            Address?: Uint8Array;
            HasRoleMint?: boolean;
            HasRoleSetITOPrices?: boolean;
        } = {};
        if (this.Address != null) {
            data.Address = this.Address;
        }
        if (this.HasRoleMint != null) {
            data.HasRoleMint = this.HasRoleMint;
        }
        if (this.HasRoleSetITOPrices != null) {
            data.HasRoleSetITOPrices = this.HasRoleSetITOPrices;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Address.length)
            writer.writeBytes(1, this.Address);
        if (this.HasRoleMint != false)
            writer.writeBool(2, this.HasRoleMint);
        if (this.HasRoleSetITOPrices != false)
            writer.writeBool(3, this.HasRoleSetITOPrices);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RolesInfo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RolesInfo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.Address = reader.readBytes();
                    break;
                case 2:
                    message.HasRoleMint = reader.readBool();
                    break;
                case 3:
                    message.HasRoleSetITOPrices = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): RolesInfo {
        return RolesInfo.deserialize(bytes);
    }
}
export class RoyaltiesInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Address?: Uint8Array;
        TransferPercentage?: RoyaltyInfo[];
        TransferFixed?: number;
        MarketPercentage?: number;
        MarketFixed?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Address" in data && data.Address != undefined) {
                this.Address = data.Address;
            }
            if ("TransferPercentage" in data && data.TransferPercentage != undefined) {
                this.TransferPercentage = data.TransferPercentage;
            }
            if ("TransferFixed" in data && data.TransferFixed != undefined) {
                this.TransferFixed = data.TransferFixed;
            }
            if ("MarketPercentage" in data && data.MarketPercentage != undefined) {
                this.MarketPercentage = data.MarketPercentage;
            }
            if ("MarketFixed" in data && data.MarketFixed != undefined) {
                this.MarketFixed = data.MarketFixed;
            }
        }
    }
    get Address() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set Address(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get TransferPercentage() {
        return pb_1.Message.getRepeatedWrapperField(this, RoyaltyInfo, 2) as RoyaltyInfo[];
    }
    set TransferPercentage(value: RoyaltyInfo[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get TransferFixed() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set TransferFixed(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get MarketPercentage() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set MarketPercentage(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get MarketFixed() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set MarketFixed(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    static fromObject(data: {
        Address?: Uint8Array;
        TransferPercentage?: ReturnType<typeof RoyaltyInfo.prototype.toObject>[];
        TransferFixed?: number;
        MarketPercentage?: number;
        MarketFixed?: number;
    }): RoyaltiesInfo {
        const message = new RoyaltiesInfo({});
        if (data.Address != null) {
            message.Address = data.Address;
        }
        if (data.TransferPercentage != null) {
            message.TransferPercentage = data.TransferPercentage.map(item => RoyaltyInfo.fromObject(item));
        }
        if (data.TransferFixed != null) {
            message.TransferFixed = data.TransferFixed;
        }
        if (data.MarketPercentage != null) {
            message.MarketPercentage = data.MarketPercentage;
        }
        if (data.MarketFixed != null) {
            message.MarketFixed = data.MarketFixed;
        }
        return message;
    }
    toObject() {
        const data: {
            Address?: Uint8Array;
            TransferPercentage?: ReturnType<typeof RoyaltyInfo.prototype.toObject>[];
            TransferFixed?: number;
            MarketPercentage?: number;
            MarketFixed?: number;
        } = {};
        if (this.Address != null) {
            data.Address = this.Address;
        }
        if (this.TransferPercentage != null) {
            data.TransferPercentage = this.TransferPercentage.map((item: RoyaltyInfo) => item.toObject());
        }
        if (this.TransferFixed != null) {
            data.TransferFixed = this.TransferFixed;
        }
        if (this.MarketPercentage != null) {
            data.MarketPercentage = this.MarketPercentage;
        }
        if (this.MarketFixed != null) {
            data.MarketFixed = this.MarketFixed;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Address.length)
            writer.writeBytes(1, this.Address);
        if (this.TransferPercentage.length)
            writer.writeRepeatedMessage(2, this.TransferPercentage, (item: RoyaltyInfo) => item.serialize(writer));
        if (this.TransferFixed != 0)
            writer.writeInt64(3, this.TransferFixed);
        if (this.MarketPercentage != 0)
            writer.writeUint32(4, this.MarketPercentage);
        if (this.MarketFixed != 0)
            writer.writeInt64(5, this.MarketFixed);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RoyaltiesInfo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RoyaltiesInfo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.Address = reader.readBytes();
                    break;
                case 2:
                    reader.readMessage(message.TransferPercentage, () => pb_1.Message.addToRepeatedWrapperField(message, 2, RoyaltyInfo.deserialize(reader), RoyaltyInfo));
                    break;
                case 3:
                    message.TransferFixed = reader.readInt64();
                    break;
                case 4:
                    message.MarketPercentage = reader.readUint32();
                    break;
                case 5:
                    message.MarketFixed = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): RoyaltiesInfo {
        return RoyaltiesInfo.deserialize(bytes);
    }
}
export class RoyaltyInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Amount?: number;
        Percentage?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Amount" in data && data.Amount != undefined) {
                this.Amount = data.Amount;
            }
            if ("Percentage" in data && data.Percentage != undefined) {
                this.Percentage = data.Percentage;
            }
        }
    }
    get Amount() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set Amount(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get Percentage() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set Percentage(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        Amount?: number;
        Percentage?: number;
    }): RoyaltyInfo {
        const message = new RoyaltyInfo({});
        if (data.Amount != null) {
            message.Amount = data.Amount;
        }
        if (data.Percentage != null) {
            message.Percentage = data.Percentage;
        }
        return message;
    }
    toObject() {
        const data: {
            Amount?: number;
            Percentage?: number;
        } = {};
        if (this.Amount != null) {
            data.Amount = this.Amount;
        }
        if (this.Percentage != null) {
            data.Percentage = this.Percentage;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Amount != 0)
            writer.writeInt64(1, this.Amount);
        if (this.Percentage != 0)
            writer.writeUint32(2, this.Percentage);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RoyaltyInfo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RoyaltyInfo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.Amount = reader.readInt64();
                    break;
                case 2:
                    message.Percentage = reader.readUint32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): RoyaltyInfo {
        return RoyaltyInfo.deserialize(bytes);
    }
}
export class AssetTriggerContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        TriggerType?: AssetTriggerContractEnumTriggerType;
        AssetID?: Uint8Array;
        ToAddress?: Uint8Array;
        Amount?: number;
        MIME?: Uint8Array;
        Logo?: string;
        URIs?: Map<string, string>;
        Role?: RolesInfo;
        Staking?: StakingInfo;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("TriggerType" in data && data.TriggerType != undefined) {
                this.TriggerType = data.TriggerType;
            }
            if ("AssetID" in data && data.AssetID != undefined) {
                this.AssetID = data.AssetID;
            }
            if ("ToAddress" in data && data.ToAddress != undefined) {
                this.ToAddress = data.ToAddress;
            }
            if ("Amount" in data && data.Amount != undefined) {
                this.Amount = data.Amount;
            }
            if ("MIME" in data && data.MIME != undefined) {
                this.MIME = data.MIME;
            }
            if ("Logo" in data && data.Logo != undefined) {
                this.Logo = data.Logo;
            }
            if ("URIs" in data && data.URIs != undefined) {
                this.URIs = data.URIs;
            }
            if ("Role" in data && data.Role != undefined) {
                this.Role = data.Role;
            }
            if ("Staking" in data && data.Staking != undefined) {
                this.Staking = data.Staking;
            }
        }
        if (!this.URIs)
            this.URIs = new Map();
    }
    get TriggerType() {
        return pb_1.Message.getFieldWithDefault(this, 1, AssetTriggerContractEnumTriggerType.Mint) as AssetTriggerContractEnumTriggerType;
    }
    set TriggerType(value: AssetTriggerContractEnumTriggerType) {
        pb_1.Message.setField(this, 1, value);
    }
    get AssetID() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set AssetID(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get ToAddress() {
        return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array()) as Uint8Array;
    }
    set ToAddress(value: Uint8Array) {
        pb_1.Message.setField(this, 3, value);
    }
    get Amount() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set Amount(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get MIME() {
        return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array()) as Uint8Array;
    }
    set MIME(value: Uint8Array) {
        pb_1.Message.setField(this, 5, value);
    }
    get Logo() {
        return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set Logo(value: string) {
        pb_1.Message.setField(this, 6, value);
    }
    get URIs() {
        return pb_1.Message.getField(this, 7) as any as Map<string, string>;
    }
    set URIs(value: Map<string, string>) {
        pb_1.Message.setField(this, 7, value as any);
    }
    get Role() {
        return pb_1.Message.getWrapperField(this, RolesInfo, 8) as RolesInfo;
    }
    set Role(value: RolesInfo) {
        pb_1.Message.setWrapperField(this, 8, value);
    }
    get has_Role() {
        return pb_1.Message.getField(this, 8) != null;
    }
    get Staking() {
        return pb_1.Message.getWrapperField(this, StakingInfo, 9) as StakingInfo;
    }
    set Staking(value: StakingInfo) {
        pb_1.Message.setWrapperField(this, 9, value);
    }
    get has_Staking() {
        return pb_1.Message.getField(this, 9) != null;
    }
    static fromObject(data: {
        TriggerType?: AssetTriggerContractEnumTriggerType;
        AssetID?: Uint8Array;
        ToAddress?: Uint8Array;
        Amount?: number;
        MIME?: Uint8Array;
        Logo?: string;
        URIs?: {
            [key: string]: string;
        };
        Role?: ReturnType<typeof RolesInfo.prototype.toObject>;
        Staking?: ReturnType<typeof StakingInfo.prototype.toObject>;
    }): AssetTriggerContract {
        const message = new AssetTriggerContract({});
        if (data.TriggerType != null) {
            message.TriggerType = data.TriggerType;
        }
        if (data.AssetID != null) {
            message.AssetID = data.AssetID;
        }
        if (data.ToAddress != null) {
            message.ToAddress = data.ToAddress;
        }
        if (data.Amount != null) {
            message.Amount = data.Amount;
        }
        if (data.MIME != null) {
            message.MIME = data.MIME;
        }
        if (data.Logo != null) {
            message.Logo = data.Logo;
        }
        if (typeof data.URIs == "object") {
            message.URIs = new Map(Object.entries(data.URIs));
        }
        if (data.Role != null) {
            message.Role = RolesInfo.fromObject(data.Role);
        }
        if (data.Staking != null) {
            message.Staking = StakingInfo.fromObject(data.Staking);
        }
        return message;
    }
    toObject() {
        const data: {
            TriggerType?: AssetTriggerContractEnumTriggerType;
            AssetID?: Uint8Array;
            ToAddress?: Uint8Array;
            Amount?: number;
            MIME?: Uint8Array;
            Logo?: string;
            URIs?: {
                [key: string]: string;
            };
            Role?: ReturnType<typeof RolesInfo.prototype.toObject>;
            Staking?: ReturnType<typeof StakingInfo.prototype.toObject>;
        } = {};
        if (this.TriggerType != null) {
            data.TriggerType = this.TriggerType;
        }
        if (this.AssetID != null) {
            data.AssetID = this.AssetID;
        }
        if (this.ToAddress != null) {
            data.ToAddress = this.ToAddress;
        }
        if (this.Amount != null) {
            data.Amount = this.Amount;
        }
        if (this.MIME != null) {
            data.MIME = this.MIME;
        }
        if (this.Logo != null) {
            data.Logo = this.Logo;
        }
        if (this.URIs.size > 0) {
            data.URIs = Object.fromEntries(this.URIs);
        }
        if (this.Role != null) {
            data.Role = this.Role.toObject();
        }
        if (this.Staking != null) {
            data.Staking = this.Staking.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.TriggerType != AssetTriggerContractEnumTriggerType.Mint)
            writer.writeEnum(1, this.TriggerType);
        if (this.AssetID.length)
            writer.writeBytes(2, this.AssetID);
        if (this.ToAddress.length)
            writer.writeBytes(3, this.ToAddress);
        if (this.Amount != 0)
            writer.writeInt64(4, this.Amount);
        if (this.MIME.length)
            writer.writeBytes(5, this.MIME);
        if (this.Logo.length)
            writer.writeString(6, this.Logo);
        for (const [key, value] of this.URIs) {
            writer.writeMessage(7, this.URIs, () => {
                writer.writeString(1, key);
                writer.writeString(2, value);
            });
        }
        if (this.has_Role)
            writer.writeMessage(8, this.Role, () => this.Role.serialize(writer));
        if (this.has_Staking)
            writer.writeMessage(9, this.Staking, () => this.Staking.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AssetTriggerContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AssetTriggerContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.TriggerType = reader.readEnum();
                    break;
                case 2:
                    message.AssetID = reader.readBytes();
                    break;
                case 3:
                    message.ToAddress = reader.readBytes();
                    break;
                case 4:
                    message.Amount = reader.readInt64();
                    break;
                case 5:
                    message.MIME = reader.readBytes();
                    break;
                case 6:
                    message.Logo = reader.readString();
                    break;
                case 7:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.URIs as any, reader, reader.readString, reader.readString));
                    break;
                case 8:
                    reader.readMessage(message.Role, () => message.Role = RolesInfo.deserialize(reader));
                    break;
                case 9:
                    reader.readMessage(message.Staking, () => message.Staking = StakingInfo.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): AssetTriggerContract {
        return AssetTriggerContract.deserialize(bytes);
    }
}
export enum AssetTriggerContractEnumTriggerType {
    Mint = 0,
    Burn = 1,
    Wipe = 2,
    Pause = 3,
    Resume = 4,
    ChangeOwner = 5,
    AddRole = 6,
    RemoveRole = 7,
    UpdateMetadata = 8,
    StopNFTMint = 9,
    UpdateLogo = 10,
    UpdateURIs = 11,
    ChangeRoyaltiesReceiver = 12,
    UpdateStaking = 13
}
export class ValidatorConfig extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        BLSPublicKey?: Uint8Array;
        RewardAddress?: Uint8Array;
        CanDelegate?: boolean;
        Commission?: number;
        MaxDelegationAmount?: number;
        Logo?: string;
        URIs?: Map<string, string>;
        Name?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("BLSPublicKey" in data && data.BLSPublicKey != undefined) {
                this.BLSPublicKey = data.BLSPublicKey;
            }
            if ("RewardAddress" in data && data.RewardAddress != undefined) {
                this.RewardAddress = data.RewardAddress;
            }
            if ("CanDelegate" in data && data.CanDelegate != undefined) {
                this.CanDelegate = data.CanDelegate;
            }
            if ("Commission" in data && data.Commission != undefined) {
                this.Commission = data.Commission;
            }
            if ("MaxDelegationAmount" in data && data.MaxDelegationAmount != undefined) {
                this.MaxDelegationAmount = data.MaxDelegationAmount;
            }
            if ("Logo" in data && data.Logo != undefined) {
                this.Logo = data.Logo;
            }
            if ("URIs" in data && data.URIs != undefined) {
                this.URIs = data.URIs;
            }
            if ("Name" in data && data.Name != undefined) {
                this.Name = data.Name;
            }
        }
        if (!this.URIs)
            this.URIs = new Map();
    }
    get BLSPublicKey() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set BLSPublicKey(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get RewardAddress() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set RewardAddress(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get CanDelegate() {
        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
    }
    set CanDelegate(value: boolean) {
        pb_1.Message.setField(this, 3, value);
    }
    get Commission() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set Commission(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get MaxDelegationAmount() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set MaxDelegationAmount(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    get Logo() {
        return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set Logo(value: string) {
        pb_1.Message.setField(this, 6, value);
    }
    get URIs() {
        return pb_1.Message.getField(this, 7) as any as Map<string, string>;
    }
    set URIs(value: Map<string, string>) {
        pb_1.Message.setField(this, 7, value as any);
    }
    get Name() {
        return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
    }
    set Name(value: string) {
        pb_1.Message.setField(this, 8, value);
    }
    static fromObject(data: {
        BLSPublicKey?: Uint8Array;
        RewardAddress?: Uint8Array;
        CanDelegate?: boolean;
        Commission?: number;
        MaxDelegationAmount?: number;
        Logo?: string;
        URIs?: {
            [key: string]: string;
        };
        Name?: string;
    }): ValidatorConfig {
        const message = new ValidatorConfig({});
        if (data.BLSPublicKey != null) {
            message.BLSPublicKey = data.BLSPublicKey;
        }
        if (data.RewardAddress != null) {
            message.RewardAddress = data.RewardAddress;
        }
        if (data.CanDelegate != null) {
            message.CanDelegate = data.CanDelegate;
        }
        if (data.Commission != null) {
            message.Commission = data.Commission;
        }
        if (data.MaxDelegationAmount != null) {
            message.MaxDelegationAmount = data.MaxDelegationAmount;
        }
        if (data.Logo != null) {
            message.Logo = data.Logo;
        }
        if (typeof data.URIs == "object") {
            message.URIs = new Map(Object.entries(data.URIs));
        }
        if (data.Name != null) {
            message.Name = data.Name;
        }
        return message;
    }
    toObject() {
        const data: {
            BLSPublicKey?: Uint8Array;
            RewardAddress?: Uint8Array;
            CanDelegate?: boolean;
            Commission?: number;
            MaxDelegationAmount?: number;
            Logo?: string;
            URIs?: {
                [key: string]: string;
            };
            Name?: string;
        } = {};
        if (this.BLSPublicKey != null) {
            data.BLSPublicKey = this.BLSPublicKey;
        }
        if (this.RewardAddress != null) {
            data.RewardAddress = this.RewardAddress;
        }
        if (this.CanDelegate != null) {
            data.CanDelegate = this.CanDelegate;
        }
        if (this.Commission != null) {
            data.Commission = this.Commission;
        }
        if (this.MaxDelegationAmount != null) {
            data.MaxDelegationAmount = this.MaxDelegationAmount;
        }
        if (this.Logo != null) {
            data.Logo = this.Logo;
        }
        if (this.URIs.size > 0) {
            data.URIs = Object.fromEntries(this.URIs);
        }
        if (this.Name != null) {
            data.Name = this.Name;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.BLSPublicKey.length)
            writer.writeBytes(1, this.BLSPublicKey);
        if (this.RewardAddress.length)
            writer.writeBytes(2, this.RewardAddress);
        if (this.CanDelegate != false)
            writer.writeBool(3, this.CanDelegate);
        if (this.Commission != 0)
            writer.writeUint32(4, this.Commission);
        if (this.MaxDelegationAmount != 0)
            writer.writeInt64(5, this.MaxDelegationAmount);
        if (this.Logo.length)
            writer.writeString(6, this.Logo);
        for (const [key, value] of this.URIs) {
            writer.writeMessage(7, this.URIs, () => {
                writer.writeString(1, key);
                writer.writeString(2, value);
            });
        }
        if (this.Name.length)
            writer.writeString(8, this.Name);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ValidatorConfig {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ValidatorConfig();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.BLSPublicKey = reader.readBytes();
                    break;
                case 2:
                    message.RewardAddress = reader.readBytes();
                    break;
                case 3:
                    message.CanDelegate = reader.readBool();
                    break;
                case 4:
                    message.Commission = reader.readUint32();
                    break;
                case 5:
                    message.MaxDelegationAmount = reader.readInt64();
                    break;
                case 6:
                    message.Logo = reader.readString();
                    break;
                case 7:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.URIs as any, reader, reader.readString, reader.readString));
                    break;
                case 8:
                    message.Name = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ValidatorConfig {
        return ValidatorConfig.deserialize(bytes);
    }
}
export class CreateValidatorContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        OwnerAddress?: Uint8Array;
        Config?: ValidatorConfig;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("OwnerAddress" in data && data.OwnerAddress != undefined) {
                this.OwnerAddress = data.OwnerAddress;
            }
            if ("Config" in data && data.Config != undefined) {
                this.Config = data.Config;
            }
        }
    }
    get OwnerAddress() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set OwnerAddress(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get Config() {
        return pb_1.Message.getWrapperField(this, ValidatorConfig, 2) as ValidatorConfig;
    }
    set Config(value: ValidatorConfig) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_Config() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        OwnerAddress?: Uint8Array;
        Config?: ReturnType<typeof ValidatorConfig.prototype.toObject>;
    }): CreateValidatorContract {
        const message = new CreateValidatorContract({});
        if (data.OwnerAddress != null) {
            message.OwnerAddress = data.OwnerAddress;
        }
        if (data.Config != null) {
            message.Config = ValidatorConfig.fromObject(data.Config);
        }
        return message;
    }
    toObject() {
        const data: {
            OwnerAddress?: Uint8Array;
            Config?: ReturnType<typeof ValidatorConfig.prototype.toObject>;
        } = {};
        if (this.OwnerAddress != null) {
            data.OwnerAddress = this.OwnerAddress;
        }
        if (this.Config != null) {
            data.Config = this.Config.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.OwnerAddress.length)
            writer.writeBytes(1, this.OwnerAddress);
        if (this.has_Config)
            writer.writeMessage(2, this.Config, () => this.Config.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateValidatorContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateValidatorContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.OwnerAddress = reader.readBytes();
                    break;
                case 2:
                    reader.readMessage(message.Config, () => message.Config = ValidatorConfig.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CreateValidatorContract {
        return CreateValidatorContract.deserialize(bytes);
    }
}
export class ValidatorConfigContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Config?: ValidatorConfig;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Config" in data && data.Config != undefined) {
                this.Config = data.Config;
            }
        }
    }
    get Config() {
        return pb_1.Message.getWrapperField(this, ValidatorConfig, 1) as ValidatorConfig;
    }
    set Config(value: ValidatorConfig) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_Config() {
        return pb_1.Message.getField(this, 1) != null;
    }
    static fromObject(data: {
        Config?: ReturnType<typeof ValidatorConfig.prototype.toObject>;
    }): ValidatorConfigContract {
        const message = new ValidatorConfigContract({});
        if (data.Config != null) {
            message.Config = ValidatorConfig.fromObject(data.Config);
        }
        return message;
    }
    toObject() {
        const data: {
            Config?: ReturnType<typeof ValidatorConfig.prototype.toObject>;
        } = {};
        if (this.Config != null) {
            data.Config = this.Config.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_Config)
            writer.writeMessage(1, this.Config, () => this.Config.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ValidatorConfigContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ValidatorConfigContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.Config, () => message.Config = ValidatorConfig.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ValidatorConfigContract {
        return ValidatorConfigContract.deserialize(bytes);
    }
}
export class FreezeContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        AssetID?: Uint8Array;
        Amount?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("AssetID" in data && data.AssetID != undefined) {
                this.AssetID = data.AssetID;
            }
            if ("Amount" in data && data.Amount != undefined) {
                this.Amount = data.Amount;
            }
        }
    }
    get AssetID() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set AssetID(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get Amount() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set Amount(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        AssetID?: Uint8Array;
        Amount?: number;
    }): FreezeContract {
        const message = new FreezeContract({});
        if (data.AssetID != null) {
            message.AssetID = data.AssetID;
        }
        if (data.Amount != null) {
            message.Amount = data.Amount;
        }
        return message;
    }
    toObject() {
        const data: {
            AssetID?: Uint8Array;
            Amount?: number;
        } = {};
        if (this.AssetID != null) {
            data.AssetID = this.AssetID;
        }
        if (this.Amount != null) {
            data.Amount = this.Amount;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.AssetID.length)
            writer.writeBytes(1, this.AssetID);
        if (this.Amount != 0)
            writer.writeInt64(2, this.Amount);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FreezeContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FreezeContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.AssetID = reader.readBytes();
                    break;
                case 2:
                    message.Amount = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FreezeContract {
        return FreezeContract.deserialize(bytes);
    }
}
export class UnfreezeContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        AssetID?: Uint8Array;
        BucketID?: Uint8Array;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("AssetID" in data && data.AssetID != undefined) {
                this.AssetID = data.AssetID;
            }
            if ("BucketID" in data && data.BucketID != undefined) {
                this.BucketID = data.BucketID;
            }
        }
    }
    get AssetID() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set AssetID(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get BucketID() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set BucketID(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        AssetID?: Uint8Array;
        BucketID?: Uint8Array;
    }): UnfreezeContract {
        const message = new UnfreezeContract({});
        if (data.AssetID != null) {
            message.AssetID = data.AssetID;
        }
        if (data.BucketID != null) {
            message.BucketID = data.BucketID;
        }
        return message;
    }
    toObject() {
        const data: {
            AssetID?: Uint8Array;
            BucketID?: Uint8Array;
        } = {};
        if (this.AssetID != null) {
            data.AssetID = this.AssetID;
        }
        if (this.BucketID != null) {
            data.BucketID = this.BucketID;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.AssetID.length)
            writer.writeBytes(1, this.AssetID);
        if (this.BucketID.length)
            writer.writeBytes(2, this.BucketID);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UnfreezeContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UnfreezeContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.AssetID = reader.readBytes();
                    break;
                case 2:
                    message.BucketID = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): UnfreezeContract {
        return UnfreezeContract.deserialize(bytes);
    }
}
export class DelegateContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        ToAddress?: Uint8Array;
        BucketID?: Uint8Array;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ToAddress" in data && data.ToAddress != undefined) {
                this.ToAddress = data.ToAddress;
            }
            if ("BucketID" in data && data.BucketID != undefined) {
                this.BucketID = data.BucketID;
            }
        }
    }
    get ToAddress() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set ToAddress(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get BucketID() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set BucketID(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        ToAddress?: Uint8Array;
        BucketID?: Uint8Array;
    }): DelegateContract {
        const message = new DelegateContract({});
        if (data.ToAddress != null) {
            message.ToAddress = data.ToAddress;
        }
        if (data.BucketID != null) {
            message.BucketID = data.BucketID;
        }
        return message;
    }
    toObject() {
        const data: {
            ToAddress?: Uint8Array;
            BucketID?: Uint8Array;
        } = {};
        if (this.ToAddress != null) {
            data.ToAddress = this.ToAddress;
        }
        if (this.BucketID != null) {
            data.BucketID = this.BucketID;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.ToAddress.length)
            writer.writeBytes(1, this.ToAddress);
        if (this.BucketID.length)
            writer.writeBytes(2, this.BucketID);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DelegateContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DelegateContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.ToAddress = reader.readBytes();
                    break;
                case 2:
                    message.BucketID = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DelegateContract {
        return DelegateContract.deserialize(bytes);
    }
}
export class UndelegateContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        BucketID?: Uint8Array;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("BucketID" in data && data.BucketID != undefined) {
                this.BucketID = data.BucketID;
            }
        }
    }
    get BucketID() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set BucketID(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        BucketID?: Uint8Array;
    }): UndelegateContract {
        const message = new UndelegateContract({});
        if (data.BucketID != null) {
            message.BucketID = data.BucketID;
        }
        return message;
    }
    toObject() {
        const data: {
            BucketID?: Uint8Array;
        } = {};
        if (this.BucketID != null) {
            data.BucketID = this.BucketID;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.BucketID.length)
            writer.writeBytes(1, this.BucketID);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UndelegateContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UndelegateContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.BucketID = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): UndelegateContract {
        return UndelegateContract.deserialize(bytes);
    }
}
export class WithdrawContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        AssetID?: Uint8Array;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("AssetID" in data && data.AssetID != undefined) {
                this.AssetID = data.AssetID;
            }
        }
    }
    get AssetID() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set AssetID(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        AssetID?: Uint8Array;
    }): WithdrawContract {
        const message = new WithdrawContract({});
        if (data.AssetID != null) {
            message.AssetID = data.AssetID;
        }
        return message;
    }
    toObject() {
        const data: {
            AssetID?: Uint8Array;
        } = {};
        if (this.AssetID != null) {
            data.AssetID = this.AssetID;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.AssetID.length)
            writer.writeBytes(1, this.AssetID);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WithdrawContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WithdrawContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.AssetID = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): WithdrawContract {
        return WithdrawContract.deserialize(bytes);
    }
}
export class ClaimContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        ClaimType?: ClaimContractEnumClaimType;
        ID?: Uint8Array;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ClaimType" in data && data.ClaimType != undefined) {
                this.ClaimType = data.ClaimType;
            }
            if ("ID" in data && data.ID != undefined) {
                this.ID = data.ID;
            }
        }
    }
    get ClaimType() {
        return pb_1.Message.getFieldWithDefault(this, 1, ClaimContractEnumClaimType.StakingClaim) as ClaimContractEnumClaimType;
    }
    set ClaimType(value: ClaimContractEnumClaimType) {
        pb_1.Message.setField(this, 1, value);
    }
    get ID() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set ID(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        ClaimType?: ClaimContractEnumClaimType;
        ID?: Uint8Array;
    }): ClaimContract {
        const message = new ClaimContract({});
        if (data.ClaimType != null) {
            message.ClaimType = data.ClaimType;
        }
        if (data.ID != null) {
            message.ID = data.ID;
        }
        return message;
    }
    toObject() {
        const data: {
            ClaimType?: ClaimContractEnumClaimType;
            ID?: Uint8Array;
        } = {};
        if (this.ClaimType != null) {
            data.ClaimType = this.ClaimType;
        }
        if (this.ID != null) {
            data.ID = this.ID;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.ClaimType != ClaimContractEnumClaimType.StakingClaim)
            writer.writeEnum(1, this.ClaimType);
        if (this.ID.length)
            writer.writeBytes(2, this.ID);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClaimContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ClaimContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.ClaimType = reader.readEnum();
                    break;
                case 2:
                    message.ID = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ClaimContract {
        return ClaimContract.deserialize(bytes);
    }
}
export enum ClaimContractEnumClaimType {
    StakingClaim = 0,
    AllowanceClaim = 1,
    MarketClaim = 2
}
export class UnjailContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") { }
    }
    static fromObject(data: {}): UnjailContract {
        const message = new UnjailContract({});
        return message;
    }
    toObject() {
        const data: {} = {};
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UnjailContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UnjailContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): UnjailContract {
        return UnjailContract.deserialize(bytes);
    }
}
export class SetAccountNameContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Name?: Uint8Array;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Name" in data && data.Name != undefined) {
                this.Name = data.Name;
            }
        }
    }
    get Name() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set Name(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        Name?: Uint8Array;
    }): SetAccountNameContract {
        const message = new SetAccountNameContract({});
        if (data.Name != null) {
            message.Name = data.Name;
        }
        return message;
    }
    toObject() {
        const data: {
            Name?: Uint8Array;
        } = {};
        if (this.Name != null) {
            data.Name = this.Name;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Name.length)
            writer.writeBytes(1, this.Name);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SetAccountNameContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SetAccountNameContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.Name = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SetAccountNameContract {
        return SetAccountNameContract.deserialize(bytes);
    }
}
export class ProposalContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Parameters?: Map<number, Uint8Array>;
        Description?: Uint8Array;
        EpochsDuration?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Parameters" in data && data.Parameters != undefined) {
                this.Parameters = data.Parameters;
            }
            if ("Description" in data && data.Description != undefined) {
                this.Description = data.Description;
            }
            if ("EpochsDuration" in data && data.EpochsDuration != undefined) {
                this.EpochsDuration = data.EpochsDuration;
            }
        }
        if (!this.Parameters)
            this.Parameters = new Map();
    }
    get Parameters() {
        return pb_1.Message.getField(this, 1) as any as Map<number, Uint8Array>;
    }
    set Parameters(value: Map<number, Uint8Array>) {
        pb_1.Message.setField(this, 1, value as any);
    }
    get Description() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set Description(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get EpochsDuration() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set EpochsDuration(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        Parameters?: {
            [key: number]: Uint8Array;
        };
        Description?: Uint8Array;
        EpochsDuration?: number;
    }): ProposalContract {
        const message = new ProposalContract({});
        if (typeof data.Parameters == "object") {
            message.Parameters = new Map(Object.entries(data.Parameters).map(([key, value]) => [Number(key), value]));
        }
        if (data.Description != null) {
            message.Description = data.Description;
        }
        if (data.EpochsDuration != null) {
            message.EpochsDuration = data.EpochsDuration;
        }
        return message;
    }
    toObject() {
        const data: {
            Parameters?: {
                [key: number]: Uint8Array;
            };
            Description?: Uint8Array;
            EpochsDuration?: number;
        } = {};
        if (this.Parameters.size > 0) {
            data.Parameters = Object.fromEntries(this.Parameters);
        }
        if (this.Description != null) {
            data.Description = this.Description;
        }
        if (this.EpochsDuration != null) {
            data.EpochsDuration = this.EpochsDuration;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        for (const [key, value] of this.Parameters) {
            writer.writeMessage(1, this.Parameters, () => {
                writer.writeInt32(1, key);
                writer.writeBytes(2, value);
            });
        }
        if (this.Description.length)
            writer.writeBytes(2, this.Description);
        if (this.EpochsDuration != 0)
            writer.writeUint32(3, this.EpochsDuration);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProposalContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProposalContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Parameters as any, reader, reader.readInt32, reader.readBytes));
                    break;
                case 2:
                    message.Description = reader.readBytes();
                    break;
                case 3:
                    message.EpochsDuration = reader.readUint32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ProposalContract {
        return ProposalContract.deserialize(bytes);
    }
}
export class VoteContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        ProposalID?: number;
        Amount?: number;
        Type?: VoteContractEnumVoteType;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ProposalID" in data && data.ProposalID != undefined) {
                this.ProposalID = data.ProposalID;
            }
            if ("Amount" in data && data.Amount != undefined) {
                this.Amount = data.Amount;
            }
            if ("Type" in data && data.Type != undefined) {
                this.Type = data.Type;
            }
        }
    }
    get ProposalID() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set ProposalID(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get Amount() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set Amount(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get Type() {
        return pb_1.Message.getFieldWithDefault(this, 3, VoteContractEnumVoteType.Yes) as VoteContractEnumVoteType;
    }
    set Type(value: VoteContractEnumVoteType) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        ProposalID?: number;
        Amount?: number;
        Type?: VoteContractEnumVoteType;
    }): VoteContract {
        const message = new VoteContract({});
        if (data.ProposalID != null) {
            message.ProposalID = data.ProposalID;
        }
        if (data.Amount != null) {
            message.Amount = data.Amount;
        }
        if (data.Type != null) {
            message.Type = data.Type;
        }
        return message;
    }
    toObject() {
        const data: {
            ProposalID?: number;
            Amount?: number;
            Type?: VoteContractEnumVoteType;
        } = {};
        if (this.ProposalID != null) {
            data.ProposalID = this.ProposalID;
        }
        if (this.Amount != null) {
            data.Amount = this.Amount;
        }
        if (this.Type != null) {
            data.Type = this.Type;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.ProposalID != 0)
            writer.writeUint64(1, this.ProposalID);
        if (this.Amount != 0)
            writer.writeInt64(2, this.Amount);
        if (this.Type != VoteContractEnumVoteType.Yes)
            writer.writeEnum(3, this.Type);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VoteContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VoteContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.ProposalID = reader.readUint64();
                    break;
                case 2:
                    message.Amount = reader.readInt64();
                    break;
                case 3:
                    message.Type = reader.readEnum();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): VoteContract {
        return VoteContract.deserialize(bytes);
    }
}
export enum VoteContractEnumVoteType {
    Yes = 0,
    No = 1
}
export class ConfigITOContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        AssetID?: Uint8Array;
        ReceiverAddress?: Uint8Array;
        Status?: ConfigITOContractEnumITOStatus;
        MaxAmount?: number;
        PackInfo?: Map<string, PackInfo>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("AssetID" in data && data.AssetID != undefined) {
                this.AssetID = data.AssetID;
            }
            if ("ReceiverAddress" in data && data.ReceiverAddress != undefined) {
                this.ReceiverAddress = data.ReceiverAddress;
            }
            if ("Status" in data && data.Status != undefined) {
                this.Status = data.Status;
            }
            if ("MaxAmount" in data && data.MaxAmount != undefined) {
                this.MaxAmount = data.MaxAmount;
            }
            if ("PackInfo" in data && data.PackInfo != undefined) {
                this.PackInfo = data.PackInfo;
            }
        }
        if (!this.PackInfo)
            this.PackInfo = new Map();
    }
    get AssetID() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set AssetID(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get ReceiverAddress() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set ReceiverAddress(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get Status() {
        return pb_1.Message.getFieldWithDefault(this, 3, ConfigITOContractEnumITOStatus.DefaultITO) as ConfigITOContractEnumITOStatus;
    }
    set Status(value: ConfigITOContractEnumITOStatus) {
        pb_1.Message.setField(this, 3, value);
    }
    get MaxAmount() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set MaxAmount(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get PackInfo() {
        return pb_1.Message.getField(this, 5) as any as Map<string, PackInfo>;
    }
    set PackInfo(value: Map<string, PackInfo>) {
        pb_1.Message.setField(this, 5, value as any);
    }
    static fromObject(data: {
        AssetID?: Uint8Array;
        ReceiverAddress?: Uint8Array;
        Status?: ConfigITOContractEnumITOStatus;
        MaxAmount?: number;
        PackInfo?: {
            [key: string]: ReturnType<typeof PackInfo.prototype.toObject>;
        };
    }): ConfigITOContract {
        const message = new ConfigITOContract({});
        if (data.AssetID != null) {
            message.AssetID = data.AssetID;
        }
        if (data.ReceiverAddress != null) {
            message.ReceiverAddress = data.ReceiverAddress;
        }
        if (data.Status != null) {
            message.Status = data.Status;
        }
        if (data.MaxAmount != null) {
            message.MaxAmount = data.MaxAmount;
        }
        if (typeof data.PackInfo == "object") {
            message.PackInfo = new Map(Object.entries(data.PackInfo).map(([key, value]) => [key, PackInfo.fromObject(value)]));
        }
        return message;
    }
    toObject() {
        const data: {
            AssetID?: Uint8Array;
            ReceiverAddress?: Uint8Array;
            Status?: ConfigITOContractEnumITOStatus;
            MaxAmount?: number;
            PackInfo?: {
                [key: string]: ReturnType<typeof PackInfo.prototype.toObject>;
            };
        } = {};
        if (this.AssetID != null) {
            data.AssetID = this.AssetID;
        }
        if (this.ReceiverAddress != null) {
            data.ReceiverAddress = this.ReceiverAddress;
        }
        if (this.Status != null) {
            data.Status = this.Status;
        }
        if (this.MaxAmount != null) {
            data.MaxAmount = this.MaxAmount;
        }
        if (this.PackInfo.size > 0) {
            data.PackInfo = Object.fromEntries(Array.from(this.PackInfo).map(([key, value]) => [key, value.toObject()]));
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.AssetID.length)
            writer.writeBytes(1, this.AssetID);
        if (this.ReceiverAddress.length)
            writer.writeBytes(2, this.ReceiverAddress);
        if (this.Status != ConfigITOContractEnumITOStatus.DefaultITO)
            writer.writeEnum(3, this.Status);
        if (this.MaxAmount != 0)
            writer.writeInt64(4, this.MaxAmount);
        for (const [key, value] of this.PackInfo) {
            writer.writeMessage(5, this.PackInfo, () => {
                writer.writeString(1, key);
                writer.writeMessage(2, value, () => value.serialize(writer));
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConfigITOContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConfigITOContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.AssetID = reader.readBytes();
                    break;
                case 2:
                    message.ReceiverAddress = reader.readBytes();
                    break;
                case 3:
                    message.Status = reader.readEnum();
                    break;
                case 4:
                    message.MaxAmount = reader.readInt64();
                    break;
                case 5:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.PackInfo as any, reader, reader.readString, () => {
                        let value;
                        reader.readMessage(message, () => value = PackInfo.deserialize(reader));
                        return value;
                    }));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ConfigITOContract {
        return ConfigITOContract.deserialize(bytes);
    }
}
export enum ConfigITOContractEnumITOStatus {
    DefaultITO = 0,
    ActiveITO = 1,
    PausedITO = 2
}
export class SetITOPricesContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        AssetID?: Uint8Array;
        PackInfo?: Map<string, PackInfo>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("AssetID" in data && data.AssetID != undefined) {
                this.AssetID = data.AssetID;
            }
            if ("PackInfo" in data && data.PackInfo != undefined) {
                this.PackInfo = data.PackInfo;
            }
        }
        if (!this.PackInfo)
            this.PackInfo = new Map();
    }
    get AssetID() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set AssetID(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get PackInfo() {
        return pb_1.Message.getField(this, 2) as any as Map<string, PackInfo>;
    }
    set PackInfo(value: Map<string, PackInfo>) {
        pb_1.Message.setField(this, 2, value as any);
    }
    static fromObject(data: {
        AssetID?: Uint8Array;
        PackInfo?: {
            [key: string]: ReturnType<typeof PackInfo.prototype.toObject>;
        };
    }): SetITOPricesContract {
        const message = new SetITOPricesContract({});
        if (data.AssetID != null) {
            message.AssetID = data.AssetID;
        }
        if (typeof data.PackInfo == "object") {
            message.PackInfo = new Map(Object.entries(data.PackInfo).map(([key, value]) => [key, PackInfo.fromObject(value)]));
        }
        return message;
    }
    toObject() {
        const data: {
            AssetID?: Uint8Array;
            PackInfo?: {
                [key: string]: ReturnType<typeof PackInfo.prototype.toObject>;
            };
        } = {};
        if (this.AssetID != null) {
            data.AssetID = this.AssetID;
        }
        if (this.PackInfo.size > 0) {
            data.PackInfo = Object.fromEntries(Array.from(this.PackInfo).map(([key, value]) => [key, value.toObject()]));
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.AssetID.length)
            writer.writeBytes(1, this.AssetID);
        for (const [key, value] of this.PackInfo) {
            writer.writeMessage(2, this.PackInfo, () => {
                writer.writeString(1, key);
                writer.writeMessage(2, value, () => value.serialize(writer));
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SetITOPricesContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SetITOPricesContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.AssetID = reader.readBytes();
                    break;
                case 2:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.PackInfo as any, reader, reader.readString, () => {
                        let value;
                        reader.readMessage(message, () => value = PackInfo.deserialize(reader));
                        return value;
                    }));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SetITOPricesContract {
        return SetITOPricesContract.deserialize(bytes);
    }
}
export class PackInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Packs?: PackItem[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Packs" in data && data.Packs != undefined) {
                this.Packs = data.Packs;
            }
        }
    }
    get Packs() {
        return pb_1.Message.getRepeatedWrapperField(this, PackItem, 1) as PackItem[];
    }
    set Packs(value: PackItem[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        Packs?: ReturnType<typeof PackItem.prototype.toObject>[];
    }): PackInfo {
        const message = new PackInfo({});
        if (data.Packs != null) {
            message.Packs = data.Packs.map(item => PackItem.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            Packs?: ReturnType<typeof PackItem.prototype.toObject>[];
        } = {};
        if (this.Packs != null) {
            data.Packs = this.Packs.map((item: PackItem) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Packs.length)
            writer.writeRepeatedMessage(1, this.Packs, (item: PackItem) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PackInfo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PackInfo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.Packs, () => pb_1.Message.addToRepeatedWrapperField(message, 1, PackItem.deserialize(reader), PackItem));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): PackInfo {
        return PackInfo.deserialize(bytes);
    }
}
export class PackItem extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Amount?: number;
        Price?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Amount" in data && data.Amount != undefined) {
                this.Amount = data.Amount;
            }
            if ("Price" in data && data.Price != undefined) {
                this.Price = data.Price;
            }
        }
    }
    get Amount() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set Amount(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get Price() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set Price(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        Amount?: number;
        Price?: number;
    }): PackItem {
        const message = new PackItem({});
        if (data.Amount != null) {
            message.Amount = data.Amount;
        }
        if (data.Price != null) {
            message.Price = data.Price;
        }
        return message;
    }
    toObject() {
        const data: {
            Amount?: number;
            Price?: number;
        } = {};
        if (this.Amount != null) {
            data.Amount = this.Amount;
        }
        if (this.Price != null) {
            data.Price = this.Price;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Amount != 0)
            writer.writeInt64(1, this.Amount);
        if (this.Price != 0)
            writer.writeInt64(2, this.Price);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PackItem {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PackItem();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.Amount = reader.readInt64();
                    break;
                case 2:
                    message.Price = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): PackItem {
        return PackItem.deserialize(bytes);
    }
}
export class BuyContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        BuyType?: BuyContractEnumBuyType;
        ID?: Uint8Array;
        CurrencyID?: Uint8Array;
        Amount?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("BuyType" in data && data.BuyType != undefined) {
                this.BuyType = data.BuyType;
            }
            if ("ID" in data && data.ID != undefined) {
                this.ID = data.ID;
            }
            if ("CurrencyID" in data && data.CurrencyID != undefined) {
                this.CurrencyID = data.CurrencyID;
            }
            if ("Amount" in data && data.Amount != undefined) {
                this.Amount = data.Amount;
            }
        }
    }
    get BuyType() {
        return pb_1.Message.getFieldWithDefault(this, 1, BuyContractEnumBuyType.ITOBuy) as BuyContractEnumBuyType;
    }
    set BuyType(value: BuyContractEnumBuyType) {
        pb_1.Message.setField(this, 1, value);
    }
    get ID() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set ID(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get CurrencyID() {
        return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array()) as Uint8Array;
    }
    set CurrencyID(value: Uint8Array) {
        pb_1.Message.setField(this, 3, value);
    }
    get Amount() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set Amount(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
        BuyType?: BuyContractEnumBuyType;
        ID?: Uint8Array;
        CurrencyID?: Uint8Array;
        Amount?: number;
    }): BuyContract {
        const message = new BuyContract({});
        if (data.BuyType != null) {
            message.BuyType = data.BuyType;
        }
        if (data.ID != null) {
            message.ID = data.ID;
        }
        if (data.CurrencyID != null) {
            message.CurrencyID = data.CurrencyID;
        }
        if (data.Amount != null) {
            message.Amount = data.Amount;
        }
        return message;
    }
    toObject() {
        const data: {
            BuyType?: BuyContractEnumBuyType;
            ID?: Uint8Array;
            CurrencyID?: Uint8Array;
            Amount?: number;
        } = {};
        if (this.BuyType != null) {
            data.BuyType = this.BuyType;
        }
        if (this.ID != null) {
            data.ID = this.ID;
        }
        if (this.CurrencyID != null) {
            data.CurrencyID = this.CurrencyID;
        }
        if (this.Amount != null) {
            data.Amount = this.Amount;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.BuyType != BuyContractEnumBuyType.ITOBuy)
            writer.writeEnum(1, this.BuyType);
        if (this.ID.length)
            writer.writeBytes(2, this.ID);
        if (this.CurrencyID.length)
            writer.writeBytes(3, this.CurrencyID);
        if (this.Amount != 0)
            writer.writeInt64(4, this.Amount);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BuyContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BuyContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.BuyType = reader.readEnum();
                    break;
                case 2:
                    message.ID = reader.readBytes();
                    break;
                case 3:
                    message.CurrencyID = reader.readBytes();
                    break;
                case 4:
                    message.Amount = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): BuyContract {
        return BuyContract.deserialize(bytes);
    }
}
export enum BuyContractEnumBuyType {
    ITOBuy = 0,
    MarketBuy = 1
}
export class SellContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        MarketType?: SellContractEnumMarketType;
        MarketplaceID?: Uint8Array;
        AssetID?: Uint8Array;
        CurrencyID?: Uint8Array;
        Price?: number;
        ReservePrice?: number;
        EndTime?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("MarketType" in data && data.MarketType != undefined) {
                this.MarketType = data.MarketType;
            }
            if ("MarketplaceID" in data && data.MarketplaceID != undefined) {
                this.MarketplaceID = data.MarketplaceID;
            }
            if ("AssetID" in data && data.AssetID != undefined) {
                this.AssetID = data.AssetID;
            }
            if ("CurrencyID" in data && data.CurrencyID != undefined) {
                this.CurrencyID = data.CurrencyID;
            }
            if ("Price" in data && data.Price != undefined) {
                this.Price = data.Price;
            }
            if ("ReservePrice" in data && data.ReservePrice != undefined) {
                this.ReservePrice = data.ReservePrice;
            }
            if ("EndTime" in data && data.EndTime != undefined) {
                this.EndTime = data.EndTime;
            }
        }
    }
    get MarketType() {
        return pb_1.Message.getFieldWithDefault(this, 1, SellContractEnumMarketType.BuyItNowMarket) as SellContractEnumMarketType;
    }
    set MarketType(value: SellContractEnumMarketType) {
        pb_1.Message.setField(this, 1, value);
    }
    get MarketplaceID() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set MarketplaceID(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get AssetID() {
        return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array()) as Uint8Array;
    }
    set AssetID(value: Uint8Array) {
        pb_1.Message.setField(this, 3, value);
    }
    get CurrencyID() {
        return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array()) as Uint8Array;
    }
    set CurrencyID(value: Uint8Array) {
        pb_1.Message.setField(this, 4, value);
    }
    get Price() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set Price(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    get ReservePrice() {
        return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
    }
    set ReservePrice(value: number) {
        pb_1.Message.setField(this, 6, value);
    }
    get EndTime() {
        return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
    }
    set EndTime(value: number) {
        pb_1.Message.setField(this, 7, value);
    }
    static fromObject(data: {
        MarketType?: SellContractEnumMarketType;
        MarketplaceID?: Uint8Array;
        AssetID?: Uint8Array;
        CurrencyID?: Uint8Array;
        Price?: number;
        ReservePrice?: number;
        EndTime?: number;
    }): SellContract {
        const message = new SellContract({});
        if (data.MarketType != null) {
            message.MarketType = data.MarketType;
        }
        if (data.MarketplaceID != null) {
            message.MarketplaceID = data.MarketplaceID;
        }
        if (data.AssetID != null) {
            message.AssetID = data.AssetID;
        }
        if (data.CurrencyID != null) {
            message.CurrencyID = data.CurrencyID;
        }
        if (data.Price != null) {
            message.Price = data.Price;
        }
        if (data.ReservePrice != null) {
            message.ReservePrice = data.ReservePrice;
        }
        if (data.EndTime != null) {
            message.EndTime = data.EndTime;
        }
        return message;
    }
    toObject() {
        const data: {
            MarketType?: SellContractEnumMarketType;
            MarketplaceID?: Uint8Array;
            AssetID?: Uint8Array;
            CurrencyID?: Uint8Array;
            Price?: number;
            ReservePrice?: number;
            EndTime?: number;
        } = {};
        if (this.MarketType != null) {
            data.MarketType = this.MarketType;
        }
        if (this.MarketplaceID != null) {
            data.MarketplaceID = this.MarketplaceID;
        }
        if (this.AssetID != null) {
            data.AssetID = this.AssetID;
        }
        if (this.CurrencyID != null) {
            data.CurrencyID = this.CurrencyID;
        }
        if (this.Price != null) {
            data.Price = this.Price;
        }
        if (this.ReservePrice != null) {
            data.ReservePrice = this.ReservePrice;
        }
        if (this.EndTime != null) {
            data.EndTime = this.EndTime;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.MarketType != SellContractEnumMarketType.BuyItNowMarket)
            writer.writeEnum(1, this.MarketType);
        if (this.MarketplaceID.length)
            writer.writeBytes(2, this.MarketplaceID);
        if (this.AssetID.length)
            writer.writeBytes(3, this.AssetID);
        if (this.CurrencyID.length)
            writer.writeBytes(4, this.CurrencyID);
        if (this.Price != 0)
            writer.writeInt64(5, this.Price);
        if (this.ReservePrice != 0)
            writer.writeInt64(6, this.ReservePrice);
        if (this.EndTime != 0)
            writer.writeInt64(7, this.EndTime);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SellContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SellContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.MarketType = reader.readEnum();
                    break;
                case 2:
                    message.MarketplaceID = reader.readBytes();
                    break;
                case 3:
                    message.AssetID = reader.readBytes();
                    break;
                case 4:
                    message.CurrencyID = reader.readBytes();
                    break;
                case 5:
                    message.Price = reader.readInt64();
                    break;
                case 6:
                    message.ReservePrice = reader.readInt64();
                    break;
                case 7:
                    message.EndTime = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SellContract {
        return SellContract.deserialize(bytes);
    }
}
export enum SellContractEnumMarketType {
    BuyItNowMarket = 0,
    AuctionMarket = 1
}
export class CancelMarketOrderContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        OrderID?: Uint8Array;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("OrderID" in data && data.OrderID != undefined) {
                this.OrderID = data.OrderID;
            }
        }
    }
    get OrderID() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set OrderID(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        OrderID?: Uint8Array;
    }): CancelMarketOrderContract {
        const message = new CancelMarketOrderContract({});
        if (data.OrderID != null) {
            message.OrderID = data.OrderID;
        }
        return message;
    }
    toObject() {
        const data: {
            OrderID?: Uint8Array;
        } = {};
        if (this.OrderID != null) {
            data.OrderID = this.OrderID;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.OrderID.length)
            writer.writeBytes(1, this.OrderID);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CancelMarketOrderContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CancelMarketOrderContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.OrderID = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CancelMarketOrderContract {
        return CancelMarketOrderContract.deserialize(bytes);
    }
}
export class CreateMarketplaceContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Name?: Uint8Array;
        ReferralAddress?: Uint8Array;
        ReferralPercentage?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Name" in data && data.Name != undefined) {
                this.Name = data.Name;
            }
            if ("ReferralAddress" in data && data.ReferralAddress != undefined) {
                this.ReferralAddress = data.ReferralAddress;
            }
            if ("ReferralPercentage" in data && data.ReferralPercentage != undefined) {
                this.ReferralPercentage = data.ReferralPercentage;
            }
        }
    }
    get Name() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set Name(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get ReferralAddress() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set ReferralAddress(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get ReferralPercentage() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set ReferralPercentage(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        Name?: Uint8Array;
        ReferralAddress?: Uint8Array;
        ReferralPercentage?: number;
    }): CreateMarketplaceContract {
        const message = new CreateMarketplaceContract({});
        if (data.Name != null) {
            message.Name = data.Name;
        }
        if (data.ReferralAddress != null) {
            message.ReferralAddress = data.ReferralAddress;
        }
        if (data.ReferralPercentage != null) {
            message.ReferralPercentage = data.ReferralPercentage;
        }
        return message;
    }
    toObject() {
        const data: {
            Name?: Uint8Array;
            ReferralAddress?: Uint8Array;
            ReferralPercentage?: number;
        } = {};
        if (this.Name != null) {
            data.Name = this.Name;
        }
        if (this.ReferralAddress != null) {
            data.ReferralAddress = this.ReferralAddress;
        }
        if (this.ReferralPercentage != null) {
            data.ReferralPercentage = this.ReferralPercentage;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Name.length)
            writer.writeBytes(1, this.Name);
        if (this.ReferralAddress.length)
            writer.writeBytes(2, this.ReferralAddress);
        if (this.ReferralPercentage != 0)
            writer.writeUint32(3, this.ReferralPercentage);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateMarketplaceContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateMarketplaceContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.Name = reader.readBytes();
                    break;
                case 2:
                    message.ReferralAddress = reader.readBytes();
                    break;
                case 3:
                    message.ReferralPercentage = reader.readUint32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CreateMarketplaceContract {
        return CreateMarketplaceContract.deserialize(bytes);
    }
}
export class ConfigMarketplaceContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        MarketplaceID?: Uint8Array;
        Name?: Uint8Array;
        ReferralAddress?: Uint8Array;
        ReferralPercentage?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("MarketplaceID" in data && data.MarketplaceID != undefined) {
                this.MarketplaceID = data.MarketplaceID;
            }
            if ("Name" in data && data.Name != undefined) {
                this.Name = data.Name;
            }
            if ("ReferralAddress" in data && data.ReferralAddress != undefined) {
                this.ReferralAddress = data.ReferralAddress;
            }
            if ("ReferralPercentage" in data && data.ReferralPercentage != undefined) {
                this.ReferralPercentage = data.ReferralPercentage;
            }
        }
    }
    get MarketplaceID() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set MarketplaceID(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get Name() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array()) as Uint8Array;
    }
    set Name(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get ReferralAddress() {
        return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array()) as Uint8Array;
    }
    set ReferralAddress(value: Uint8Array) {
        pb_1.Message.setField(this, 3, value);
    }
    get ReferralPercentage() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set ReferralPercentage(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
        MarketplaceID?: Uint8Array;
        Name?: Uint8Array;
        ReferralAddress?: Uint8Array;
        ReferralPercentage?: number;
    }): ConfigMarketplaceContract {
        const message = new ConfigMarketplaceContract({});
        if (data.MarketplaceID != null) {
            message.MarketplaceID = data.MarketplaceID;
        }
        if (data.Name != null) {
            message.Name = data.Name;
        }
        if (data.ReferralAddress != null) {
            message.ReferralAddress = data.ReferralAddress;
        }
        if (data.ReferralPercentage != null) {
            message.ReferralPercentage = data.ReferralPercentage;
        }
        return message;
    }
    toObject() {
        const data: {
            MarketplaceID?: Uint8Array;
            Name?: Uint8Array;
            ReferralAddress?: Uint8Array;
            ReferralPercentage?: number;
        } = {};
        if (this.MarketplaceID != null) {
            data.MarketplaceID = this.MarketplaceID;
        }
        if (this.Name != null) {
            data.Name = this.Name;
        }
        if (this.ReferralAddress != null) {
            data.ReferralAddress = this.ReferralAddress;
        }
        if (this.ReferralPercentage != null) {
            data.ReferralPercentage = this.ReferralPercentage;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.MarketplaceID.length)
            writer.writeBytes(1, this.MarketplaceID);
        if (this.Name.length)
            writer.writeBytes(2, this.Name);
        if (this.ReferralAddress.length)
            writer.writeBytes(3, this.ReferralAddress);
        if (this.ReferralPercentage != 0)
            writer.writeUint32(4, this.ReferralPercentage);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConfigMarketplaceContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConfigMarketplaceContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.MarketplaceID = reader.readBytes();
                    break;
                case 2:
                    message.Name = reader.readBytes();
                    break;
                case 3:
                    message.ReferralAddress = reader.readBytes();
                    break;
                case 4:
                    message.ReferralPercentage = reader.readUint32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ConfigMarketplaceContract {
        return ConfigMarketplaceContract.deserialize(bytes);
    }
}
export class AccKey extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        address?: Uint8Array;
        weight?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("address" in data && data.address != undefined) {
                this.address = data.address;
            }
            if ("weight" in data && data.weight != undefined) {
                this.weight = data.weight;
            }
        }
    }
    get address() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
    }
    set address(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get weight() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set weight(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        address?: Uint8Array;
        weight?: number;
    }): AccKey {
        const message = new AccKey({});
        if (data.address != null) {
            message.address = data.address;
        }
        if (data.weight != null) {
            message.weight = data.weight;
        }
        return message;
    }
    toObject() {
        const data: {
            address?: Uint8Array;
            weight?: number;
        } = {};
        if (this.address != null) {
            data.address = this.address;
        }
        if (this.weight != null) {
            data.weight = this.weight;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.address.length)
            writer.writeBytes(1, this.address);
        if (this.weight != 0)
            writer.writeInt64(2, this.weight);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AccKey {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AccKey();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.address = reader.readBytes();
                    break;
                case 2:
                    message.weight = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): AccKey {
        return AccKey.deserialize(bytes);
    }
}
export class AccPermission extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Type?: AccPermissionAccPermissionType;
        PermissionName?: string;
        Threshold?: number;
        Operations?: Uint8Array;
        Signers?: AccKey[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Type" in data && data.Type != undefined) {
                this.Type = data.Type;
            }
            if ("PermissionName" in data && data.PermissionName != undefined) {
                this.PermissionName = data.PermissionName;
            }
            if ("Threshold" in data && data.Threshold != undefined) {
                this.Threshold = data.Threshold;
            }
            if ("Operations" in data && data.Operations != undefined) {
                this.Operations = data.Operations;
            }
            if ("Signers" in data && data.Signers != undefined) {
                this.Signers = data.Signers;
            }
        }
    }
    get Type() {
        return pb_1.Message.getFieldWithDefault(this, 2, AccPermissionAccPermissionType.Owner) as AccPermissionAccPermissionType;
    }
    set Type(value: AccPermissionAccPermissionType) {
        pb_1.Message.setField(this, 2, value);
    }
    get PermissionName() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set PermissionName(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get Threshold() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set Threshold(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get Operations() {
        return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array()) as Uint8Array;
    }
    set Operations(value: Uint8Array) {
        pb_1.Message.setField(this, 5, value);
    }
    get Signers() {
        return pb_1.Message.getRepeatedWrapperField(this, AccKey, 6) as AccKey[];
    }
    set Signers(value: AccKey[]) {
        pb_1.Message.setRepeatedWrapperField(this, 6, value);
    }
    static fromObject(data: {
        Type?: AccPermissionAccPermissionType;
        PermissionName?: string;
        Threshold?: number;
        Operations?: Uint8Array;
        Signers?: ReturnType<typeof AccKey.prototype.toObject>[];
    }): AccPermission {
        const message = new AccPermission({});
        if (data.Type != null) {
            message.Type = data.Type;
        }
        if (data.PermissionName != null) {
            message.PermissionName = data.PermissionName;
        }
        if (data.Threshold != null) {
            message.Threshold = data.Threshold;
        }
        if (data.Operations != null) {
            message.Operations = data.Operations;
        }
        if (data.Signers != null) {
            message.Signers = data.Signers.map(item => AccKey.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            Type?: AccPermissionAccPermissionType;
            PermissionName?: string;
            Threshold?: number;
            Operations?: Uint8Array;
            Signers?: ReturnType<typeof AccKey.prototype.toObject>[];
        } = {};
        if (this.Type != null) {
            data.Type = this.Type;
        }
        if (this.PermissionName != null) {
            data.PermissionName = this.PermissionName;
        }
        if (this.Threshold != null) {
            data.Threshold = this.Threshold;
        }
        if (this.Operations != null) {
            data.Operations = this.Operations;
        }
        if (this.Signers != null) {
            data.Signers = this.Signers.map((item: AccKey) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Type != AccPermissionAccPermissionType.Owner)
            writer.writeEnum(2, this.Type);
        if (this.PermissionName.length)
            writer.writeString(3, this.PermissionName);
        if (this.Threshold != 0)
            writer.writeInt64(4, this.Threshold);
        if (this.Operations.length)
            writer.writeBytes(5, this.Operations);
        if (this.Signers.length)
            writer.writeRepeatedMessage(6, this.Signers, (item: AccKey) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AccPermission {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AccPermission();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 2:
                    message.Type = reader.readEnum();
                    break;
                case 3:
                    message.PermissionName = reader.readString();
                    break;
                case 4:
                    message.Threshold = reader.readInt64();
                    break;
                case 5:
                    message.Operations = reader.readBytes();
                    break;
                case 6:
                    reader.readMessage(message.Signers, () => pb_1.Message.addToRepeatedWrapperField(message, 6, AccKey.deserialize(reader), AccKey));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): AccPermission {
        return AccPermission.deserialize(bytes);
    }
}
export enum AccPermissionAccPermissionType {
    Owner = 0,
    User = 1
}
export class UpdateAccountPermissionContract extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Permissions?: AccPermission[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [8], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Permissions" in data && data.Permissions != undefined) {
                this.Permissions = data.Permissions;
            }
        }
    }
    get Permissions() {
        return pb_1.Message.getRepeatedWrapperField(this, AccPermission, 8) as AccPermission[];
    }
    set Permissions(value: AccPermission[]) {
        pb_1.Message.setRepeatedWrapperField(this, 8, value);
    }
    static fromObject(data: {
        Permissions?: ReturnType<typeof AccPermission.prototype.toObject>[];
    }): UpdateAccountPermissionContract {
        const message = new UpdateAccountPermissionContract({});
        if (data.Permissions != null) {
            message.Permissions = data.Permissions.map(item => AccPermission.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            Permissions?: ReturnType<typeof AccPermission.prototype.toObject>[];
        } = {};
        if (this.Permissions != null) {
            data.Permissions = this.Permissions.map((item: AccPermission) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Permissions.length)
            writer.writeRepeatedMessage(8, this.Permissions, (item: AccPermission) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateAccountPermissionContract {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UpdateAccountPermissionContract();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 8:
                    reader.readMessage(message.Permissions, () => pb_1.Message.addToRepeatedWrapperField(message, 8, AccPermission.deserialize(reader), AccPermission));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): UpdateAccountPermissionContract {
        return UpdateAccountPermissionContract.deserialize(bytes);
    }
}
